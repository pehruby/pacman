
Pacman.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001cc  00800100  00001c2a  00001cbe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001c2a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000028b  008002cc  008002cc  00001e8a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001e8a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001ebc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003a8  00000000  00000000  00001efc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010af1  00000000  00000000  000022a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001e87  00000000  00000000  00012d95  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000041d7  00000000  00000000  00014c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001038  00000000  00000000  00018df4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005585  00000000  00000000  00019e2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a7cc  00000000  00000000  0001f3b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000588  00000000  00000000  00029b7d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
       4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
       8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
       c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      40:	0c 94 81 0c 	jmp	0x1902	; 0x1902 <__vector_16>
      44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      48:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      4c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
      68:	15 03       	mulsu	r17, r21

0000006a <__ctors_end>:
      6a:	11 24       	eor	r1, r1
      6c:	1f be       	out	0x3f, r1	; 63
      6e:	cf ef       	ldi	r28, 0xFF	; 255
      70:	d8 e0       	ldi	r29, 0x08	; 8
      72:	de bf       	out	0x3e, r29	; 62
      74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
      76:	12 e0       	ldi	r17, 0x02	; 2
      78:	a0 e0       	ldi	r26, 0x00	; 0
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	ea e2       	ldi	r30, 0x2A	; 42
      7e:	fc e1       	ldi	r31, 0x1C	; 28
      80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
      82:	05 90       	lpm	r0, Z+
      84:	0d 92       	st	X+, r0
      86:	ac 3c       	cpi	r26, 0xCC	; 204
      88:	b1 07       	cpc	r27, r17
      8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
      8c:	25 e0       	ldi	r18, 0x05	; 5
      8e:	ac ec       	ldi	r26, 0xCC	; 204
      90:	b2 e0       	ldi	r27, 0x02	; 2
      92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
      94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
      96:	a7 35       	cpi	r26, 0x57	; 87
      98:	b2 07       	cpc	r27, r18
      9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
      9c:	10 e0       	ldi	r17, 0x00	; 0
      9e:	c5 e3       	ldi	r28, 0x35	; 53
      a0:	d0 e0       	ldi	r29, 0x00	; 0
      a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
      a4:	21 97       	sbiw	r28, 0x01	; 1
      a6:	fe 01       	movw	r30, r28
      a8:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <__tablejump2__>
      ac:	c4 33       	cpi	r28, 0x34	; 52
      ae:	d1 07       	cpc	r29, r17
      b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
      b2:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <main>
      b6:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <_exit>

000000ba <__bad_interrupt>:
      ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <_Z10fill_solidP4CRGBiRKS_>:
      be:	da 01       	movw	r26, r20
      c0:	fc 01       	movw	r30, r24
      c2:	80 e0       	ldi	r24, 0x00	; 0
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	86 17       	cp	r24, r22
      c8:	97 07       	cpc	r25, r23
      ca:	6c f4       	brge	.+26     	; 0xe6 <_Z10fill_solidP4CRGBiRKS_+0x28>
      cc:	2c 91       	ld	r18, X
      ce:	20 83       	st	Z, r18
      d0:	11 96       	adiw	r26, 0x01	; 1
      d2:	2c 91       	ld	r18, X
      d4:	11 97       	sbiw	r26, 0x01	; 1
      d6:	21 83       	std	Z+1, r18	; 0x01
      d8:	12 96       	adiw	r26, 0x02	; 2
      da:	2c 91       	ld	r18, X
      dc:	12 97       	sbiw	r26, 0x02	; 2
      de:	22 83       	std	Z+2, r18	; 0x02
      e0:	01 96       	adiw	r24, 0x01	; 1
      e2:	33 96       	adiw	r30, 0x03	; 3
      e4:	f0 cf       	rjmp	.-32     	; 0xc6 <_Z10fill_solidP4CRGBiRKS_+0x8>
      e6:	08 95       	ret

000000e8 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>:
      e8:	8f 92       	push	r8
      ea:	9f 92       	push	r9
      ec:	af 92       	push	r10
      ee:	bf 92       	push	r11
      f0:	cf 92       	push	r12
      f2:	df 92       	push	r13
      f4:	ef 92       	push	r14
      f6:	ff 92       	push	r15
      f8:	0f 93       	push	r16
      fa:	1f 93       	push	r17
      fc:	cf 93       	push	r28
      fe:	df 93       	push	r29
     100:	ec 01       	movw	r28, r24
     102:	18 82       	st	Y, r1
     104:	19 82       	std	Y+1, r1	; 0x01
     106:	1a 82       	std	Y+2, r1	; 0x02
     108:	66 23       	and	r22, r22
     10a:	c1 f1       	breq	.+112    	; 0x17c <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x94>
     10c:	fa 01       	movw	r30, r20
     10e:	89 01       	movw	r16, r18
     110:	7c 01       	movw	r14, r24
     112:	6a 01       	movw	r12, r20
     114:	83 e0       	ldi	r24, 0x03	; 3
     116:	c8 0e       	add	r12, r24
     118:	d1 1c       	adc	r13, r1
     11a:	86 2e       	mov	r8, r22
     11c:	91 2c       	mov	r9, r1
     11e:	a1 2c       	mov	r10, r1
     120:	b1 2c       	mov	r11, r1
     122:	21 91       	ld	r18, Z+
     124:	22 23       	and	r18, r18
     126:	11 f1       	breq	.+68     	; 0x16c <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x84>
     128:	d8 01       	movw	r26, r16
     12a:	6c 91       	ld	r22, X
     12c:	66 23       	and	r22, r22
     12e:	f1 f0       	breq	.+60     	; 0x16c <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x84>
     130:	82 2f       	mov	r24, r18
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	a0 e0       	ldi	r26, 0x00	; 0
     136:	b0 e0       	ldi	r27, 0x00	; 0
     138:	9c 01       	movw	r18, r24
     13a:	ad 01       	movw	r20, r26
     13c:	2f 5f       	subi	r18, 0xFF	; 255
     13e:	3f 4f       	sbci	r19, 0xFF	; 255
     140:	4f 4f       	sbci	r20, 0xFF	; 255
     142:	5f 4f       	sbci	r21, 0xFF	; 255
     144:	86 2f       	mov	r24, r22
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	a0 e0       	ldi	r26, 0x00	; 0
     14a:	b0 e0       	ldi	r27, 0x00	; 0
     14c:	bc 01       	movw	r22, r24
     14e:	cd 01       	movw	r24, r26
     150:	6f 5f       	subi	r22, 0xFF	; 255
     152:	7f 4f       	sbci	r23, 0xFF	; 255
     154:	8f 4f       	sbci	r24, 0xFF	; 255
     156:	9f 4f       	sbci	r25, 0xFF	; 255
     158:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <__mulsi3>
     15c:	9b 01       	movw	r18, r22
     15e:	ac 01       	movw	r20, r24
     160:	c5 01       	movw	r24, r10
     162:	b4 01       	movw	r22, r8
     164:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <__mulsi3>
     168:	d7 01       	movw	r26, r14
     16a:	8c 93       	st	X, r24
     16c:	0f 5f       	subi	r16, 0xFF	; 255
     16e:	1f 4f       	sbci	r17, 0xFF	; 255
     170:	bf ef       	ldi	r27, 0xFF	; 255
     172:	eb 1a       	sub	r14, r27
     174:	fb 0a       	sbc	r15, r27
     176:	ec 15       	cp	r30, r12
     178:	fd 05       	cpc	r31, r13
     17a:	99 f6       	brne	.-90     	; 0x122 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x3a>
     17c:	ce 01       	movw	r24, r28
     17e:	df 91       	pop	r29
     180:	cf 91       	pop	r28
     182:	1f 91       	pop	r17
     184:	0f 91       	pop	r16
     186:	ff 90       	pop	r15
     188:	ef 90       	pop	r14
     18a:	df 90       	pop	r13
     18c:	cf 90       	pop	r12
     18e:	bf 90       	pop	r11
     190:	af 90       	pop	r10
     192:	9f 90       	pop	r9
     194:	8f 90       	pop	r8
     196:	08 95       	ret

00000198 <_ZN8CFastLEDC1Ev>:
     198:	fc 01       	movw	r30, r24
     19a:	8f ef       	ldi	r24, 0xFF	; 255
     19c:	80 83       	st	Z, r24
     19e:	12 82       	std	Z+2, r1	; 0x02
     1a0:	11 82       	std	Z+1, r1	; 0x01
     1a2:	14 86       	std	Z+12, r1	; 0x0c
     1a4:	13 86       	std	Z+11, r1	; 0x0b
     1a6:	8f ef       	ldi	r24, 0xFF	; 255
     1a8:	9f ef       	ldi	r25, 0xFF	; 255
     1aa:	dc 01       	movw	r26, r24
     1ac:	87 83       	std	Z+7, r24	; 0x07
     1ae:	90 87       	std	Z+8, r25	; 0x08
     1b0:	a1 87       	std	Z+9, r26	; 0x09
     1b2:	b2 87       	std	Z+10, r27	; 0x0a
     1b4:	08 95       	ret

000001b6 <_ZN8CFastLED9clearDataEv>:
     1b6:	cf 93       	push	r28
     1b8:	df 93       	push	r29
     1ba:	c0 91 d8 02 	lds	r28, 0x02D8	; 0x8002d8 <_ZN14CLEDController7m_pHeadE>
     1be:	d0 91 d9 02 	lds	r29, 0x02D9	; 0x8002d9 <_ZN14CLEDController7m_pHeadE+0x1>
     1c2:	20 97       	sbiw	r28, 0x00	; 0
     1c4:	91 f0       	breq	.+36     	; 0x1ea <_ZN8CFastLED9clearDataEv+0x34>
     1c6:	8a 81       	ldd	r24, Y+2	; 0x02
     1c8:	9b 81       	ldd	r25, Y+3	; 0x03
     1ca:	00 97       	sbiw	r24, 0x00	; 0
     1cc:	51 f0       	breq	.+20     	; 0x1e2 <_ZN8CFastLED9clearDataEv+0x2c>
     1ce:	4d 85       	ldd	r20, Y+13	; 0x0d
     1d0:	5e 85       	ldd	r21, Y+14	; 0x0e
     1d2:	9a 01       	movw	r18, r20
     1d4:	22 0f       	add	r18, r18
     1d6:	33 1f       	adc	r19, r19
     1d8:	42 0f       	add	r20, r18
     1da:	53 1f       	adc	r21, r19
     1dc:	60 e0       	ldi	r22, 0x00	; 0
     1de:	0e 94 19 03 	call	0x632	; 0x632 <memset8>
     1e2:	0c 80       	ldd	r0, Y+4	; 0x04
     1e4:	dd 81       	ldd	r29, Y+5	; 0x05
     1e6:	c0 2d       	mov	r28, r0
     1e8:	ec cf       	rjmp	.-40     	; 0x1c2 <_ZN8CFastLED9clearDataEv+0xc>
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	08 95       	ret

000001f0 <_ZN8CFastLED8countFPSEi>:
     1f0:	cf 92       	push	r12
     1f2:	df 92       	push	r13
     1f4:	ef 92       	push	r14
     1f6:	ff 92       	push	r15
     1f8:	0f 93       	push	r16
     1fa:	1f 93       	push	r17
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
     200:	20 91 d0 02 	lds	r18, 0x02D0	; 0x8002d0 <_ZZN8CFastLED8countFPSEiE2br>
     204:	30 91 d1 02 	lds	r19, 0x02D1	; 0x8002d1 <_ZZN8CFastLED8countFPSEiE2br+0x1>
     208:	a9 01       	movw	r20, r18
     20a:	4f 5f       	subi	r20, 0xFF	; 255
     20c:	5f 4f       	sbci	r21, 0xFF	; 255
     20e:	50 93 d1 02 	sts	0x02D1, r21	; 0x8002d1 <_ZZN8CFastLED8countFPSEiE2br+0x1>
     212:	40 93 d0 02 	sts	0x02D0, r20	; 0x8002d0 <_ZZN8CFastLED8countFPSEiE2br>
     216:	26 17       	cp	r18, r22
     218:	37 07       	cpc	r19, r23
     21a:	b4 f1       	brlt	.+108    	; 0x288 <_ZN8CFastLED8countFPSEi+0x98>
     21c:	ec 01       	movw	r28, r24
     21e:	0e 94 cb 0c 	call	0x1996	; 0x1996 <millis>
     222:	8b 01       	movw	r16, r22
     224:	9c 01       	movw	r18, r24
     226:	e0 91 d0 02 	lds	r30, 0x02D0	; 0x8002d0 <_ZZN8CFastLED8countFPSEiE2br>
     22a:	f0 91 d1 02 	lds	r31, 0x02D1	; 0x8002d1 <_ZZN8CFastLED8countFPSEiE2br+0x1>
     22e:	88 ee       	ldi	r24, 0xE8	; 232
     230:	93 e0       	ldi	r25, 0x03	; 3
     232:	e8 9f       	mul	r30, r24
     234:	b0 01       	movw	r22, r0
     236:	e9 9f       	mul	r30, r25
     238:	70 0d       	add	r23, r0
     23a:	f8 9f       	mul	r31, r24
     23c:	70 0d       	add	r23, r0
     23e:	11 24       	eor	r1, r1
     240:	07 2e       	mov	r0, r23
     242:	00 0c       	add	r0, r0
     244:	88 0b       	sbc	r24, r24
     246:	99 0b       	sbc	r25, r25
     248:	c0 90 cc 02 	lds	r12, 0x02CC	; 0x8002cc <__data_end>
     24c:	d0 90 cd 02 	lds	r13, 0x02CD	; 0x8002cd <__data_end+0x1>
     250:	e0 90 ce 02 	lds	r14, 0x02CE	; 0x8002ce <__data_end+0x2>
     254:	f0 90 cf 02 	lds	r15, 0x02CF	; 0x8002cf <__data_end+0x3>
     258:	a9 01       	movw	r20, r18
     25a:	98 01       	movw	r18, r16
     25c:	2c 19       	sub	r18, r12
     25e:	3d 09       	sbc	r19, r13
     260:	4e 09       	sbc	r20, r14
     262:	5f 09       	sbc	r21, r15
     264:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <__udivmodsi4>
     268:	3a 83       	std	Y+2, r19	; 0x02
     26a:	29 83       	std	Y+1, r18	; 0x01
     26c:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <_ZZN8CFastLED8countFPSEiE2br+0x1>
     270:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <_ZZN8CFastLED8countFPSEiE2br>
     274:	0e 94 cb 0c 	call	0x1996	; 0x1996 <millis>
     278:	60 93 cc 02 	sts	0x02CC, r22	; 0x8002cc <__data_end>
     27c:	70 93 cd 02 	sts	0x02CD, r23	; 0x8002cd <__data_end+0x1>
     280:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <__data_end+0x2>
     284:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <__data_end+0x3>
     288:	df 91       	pop	r29
     28a:	cf 91       	pop	r28
     28c:	1f 91       	pop	r17
     28e:	0f 91       	pop	r16
     290:	ff 90       	pop	r15
     292:	ef 90       	pop	r14
     294:	df 90       	pop	r13
     296:	cf 90       	pop	r12
     298:	08 95       	ret

0000029a <_ZN8CFastLED4showEh>:
     29a:	af 92       	push	r10
     29c:	bf 92       	push	r11
     29e:	cf 92       	push	r12
     2a0:	df 92       	push	r13
     2a2:	ef 92       	push	r14
     2a4:	ff 92       	push	r15
     2a6:	0f 93       	push	r16
     2a8:	1f 93       	push	r17
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	00 d0       	rcall	.+0      	; 0x2b0 <_ZN8CFastLED4showEh+0x16>
     2b0:	1f 92       	push	r1
     2b2:	cd b7       	in	r28, 0x3d	; 61
     2b4:	de b7       	in	r29, 0x3e	; 62
     2b6:	7c 01       	movw	r14, r24
     2b8:	d6 2e       	mov	r13, r22
     2ba:	f7 01       	movw	r30, r14
     2bc:	83 81       	ldd	r24, Z+3	; 0x03
     2be:	94 81       	ldd	r25, Z+4	; 0x04
     2c0:	a5 81       	ldd	r26, Z+5	; 0x05
     2c2:	b6 81       	ldd	r27, Z+6	; 0x06
     2c4:	89 2b       	or	r24, r25
     2c6:	8a 2b       	or	r24, r26
     2c8:	8b 2b       	or	r24, r27
     2ca:	d1 f0       	breq	.+52     	; 0x300 <_ZN8CFastLED4showEh+0x66>
     2cc:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
     2d0:	00 91 d2 02 	lds	r16, 0x02D2	; 0x8002d2 <_ZL8lastshow>
     2d4:	10 91 d3 02 	lds	r17, 0x02D3	; 0x8002d3 <_ZL8lastshow+0x1>
     2d8:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <_ZL8lastshow+0x2>
     2dc:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <_ZL8lastshow+0x3>
     2e0:	dc 01       	movw	r26, r24
     2e2:	cb 01       	movw	r24, r22
     2e4:	80 1b       	sub	r24, r16
     2e6:	91 0b       	sbc	r25, r17
     2e8:	a2 0b       	sbc	r26, r18
     2ea:	b3 0b       	sbc	r27, r19
     2ec:	f7 01       	movw	r30, r14
     2ee:	03 81       	ldd	r16, Z+3	; 0x03
     2f0:	14 81       	ldd	r17, Z+4	; 0x04
     2f2:	25 81       	ldd	r18, Z+5	; 0x05
     2f4:	36 81       	ldd	r19, Z+6	; 0x06
     2f6:	80 17       	cp	r24, r16
     2f8:	91 07       	cpc	r25, r17
     2fa:	a2 07       	cpc	r26, r18
     2fc:	b3 07       	cpc	r27, r19
     2fe:	e8 f2       	brcs	.-70     	; 0x2ba <_ZN8CFastLED4showEh+0x20>
     300:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
     304:	60 93 d2 02 	sts	0x02D2, r22	; 0x8002d2 <_ZL8lastshow>
     308:	70 93 d3 02 	sts	0x02D3, r23	; 0x8002d3 <_ZL8lastshow+0x1>
     30c:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <_ZL8lastshow+0x2>
     310:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <_ZL8lastshow+0x3>
     314:	d7 01       	movw	r26, r14
     316:	1b 96       	adiw	r26, 0x0b	; 11
     318:	ed 91       	ld	r30, X+
     31a:	fc 91       	ld	r31, X
     31c:	1c 97       	sbiw	r26, 0x0c	; 12
     31e:	30 97       	sbiw	r30, 0x00	; 0
     320:	51 f0       	breq	.+20     	; 0x336 <_ZN8CFastLED4showEh+0x9c>
     322:	d7 01       	movw	r26, r14
     324:	17 96       	adiw	r26, 0x07	; 7
     326:	4d 91       	ld	r20, X+
     328:	5d 91       	ld	r21, X+
     32a:	6d 91       	ld	r22, X+
     32c:	7c 91       	ld	r23, X
     32e:	1a 97       	sbiw	r26, 0x0a	; 10
     330:	8d 2d       	mov	r24, r13
     332:	09 95       	icall
     334:	d8 2e       	mov	r13, r24
     336:	00 91 d8 02 	lds	r16, 0x02D8	; 0x8002d8 <_ZN14CLEDController7m_pHeadE>
     33a:	10 91 d9 02 	lds	r17, 0x02D9	; 0x8002d9 <_ZN14CLEDController7m_pHeadE+0x1>
     33e:	01 15       	cp	r16, r1
     340:	11 05       	cpc	r17, r1
     342:	79 f1       	breq	.+94     	; 0x3a2 <_ZN8CFastLED4showEh+0x108>
     344:	f8 01       	movw	r30, r16
     346:	c4 84       	ldd	r12, Z+12	; 0x0c
     348:	d7 01       	movw	r26, r14
     34a:	11 96       	adiw	r26, 0x01	; 1
     34c:	8d 91       	ld	r24, X+
     34e:	9c 91       	ld	r25, X
     350:	12 97       	sbiw	r26, 0x02	; 2
     352:	84 36       	cpi	r24, 0x64	; 100
     354:	91 05       	cpc	r25, r1
     356:	08 f4       	brcc	.+2      	; 0x35a <_ZN8CFastLED4showEh+0xc0>
     358:	14 86       	std	Z+12, r1	; 0x0c
     35a:	d8 01       	movw	r26, r16
     35c:	ed 91       	ld	r30, X+
     35e:	fc 91       	ld	r31, X
     360:	a2 80       	ldd	r10, Z+2	; 0x02
     362:	b3 80       	ldd	r11, Z+3	; 0x03
     364:	98 01       	movw	r18, r16
     366:	27 5f       	subi	r18, 0xF7	; 247
     368:	3f 4f       	sbci	r19, 0xFF	; 255
     36a:	a8 01       	movw	r20, r16
     36c:	4a 5f       	subi	r20, 0xFA	; 250
     36e:	5f 4f       	sbci	r21, 0xFF	; 255
     370:	6d 2d       	mov	r22, r13
     372:	ce 01       	movw	r24, r28
     374:	01 96       	adiw	r24, 0x01	; 1
     376:	0e 94 74 00 	call	0xe8	; 0xe8 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>
     37a:	f8 01       	movw	r30, r16
     37c:	45 85       	ldd	r20, Z+13	; 0x0d
     37e:	56 85       	ldd	r21, Z+14	; 0x0e
     380:	62 81       	ldd	r22, Z+2	; 0x02
     382:	73 81       	ldd	r23, Z+3	; 0x03
     384:	9e 01       	movw	r18, r28
     386:	2f 5f       	subi	r18, 0xFF	; 255
     388:	3f 4f       	sbci	r19, 0xFF	; 255
     38a:	c8 01       	movw	r24, r16
     38c:	f5 01       	movw	r30, r10
     38e:	09 95       	icall
     390:	d8 01       	movw	r26, r16
     392:	1c 96       	adiw	r26, 0x0c	; 12
     394:	cc 92       	st	X, r12
     396:	1c 97       	sbiw	r26, 0x0c	; 12
     398:	14 96       	adiw	r26, 0x04	; 4
     39a:	0d 91       	ld	r16, X+
     39c:	1c 91       	ld	r17, X
     39e:	15 97       	sbiw	r26, 0x05	; 5
     3a0:	ce cf       	rjmp	.-100    	; 0x33e <_ZN8CFastLED4showEh+0xa4>
     3a2:	69 e1       	ldi	r22, 0x19	; 25
     3a4:	70 e0       	ldi	r23, 0x00	; 0
     3a6:	c7 01       	movw	r24, r14
     3a8:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <_ZN8CFastLED8countFPSEi>
     3ac:	0f 90       	pop	r0
     3ae:	0f 90       	pop	r0
     3b0:	0f 90       	pop	r0
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	1f 91       	pop	r17
     3b8:	0f 91       	pop	r16
     3ba:	ff 90       	pop	r15
     3bc:	ef 90       	pop	r14
     3be:	df 90       	pop	r13
     3c0:	cf 90       	pop	r12
     3c2:	bf 90       	pop	r11
     3c4:	af 90       	pop	r10
     3c6:	08 95       	ret

000003c8 <_ZN8CFastLED9showColorERK4CRGBh>:
     3c8:	8f 92       	push	r8
     3ca:	9f 92       	push	r9
     3cc:	af 92       	push	r10
     3ce:	bf 92       	push	r11
     3d0:	cf 92       	push	r12
     3d2:	df 92       	push	r13
     3d4:	ef 92       	push	r14
     3d6:	ff 92       	push	r15
     3d8:	0f 93       	push	r16
     3da:	1f 93       	push	r17
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	00 d0       	rcall	.+0      	; 0x3e2 <_ZN8CFastLED9showColorERK4CRGBh+0x1a>
     3e2:	1f 92       	push	r1
     3e4:	cd b7       	in	r28, 0x3d	; 61
     3e6:	de b7       	in	r29, 0x3e	; 62
     3e8:	7c 01       	movw	r14, r24
     3ea:	5b 01       	movw	r10, r22
     3ec:	d4 2e       	mov	r13, r20
     3ee:	f7 01       	movw	r30, r14
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	94 81       	ldd	r25, Z+4	; 0x04
     3f4:	a5 81       	ldd	r26, Z+5	; 0x05
     3f6:	b6 81       	ldd	r27, Z+6	; 0x06
     3f8:	89 2b       	or	r24, r25
     3fa:	8a 2b       	or	r24, r26
     3fc:	8b 2b       	or	r24, r27
     3fe:	d1 f0       	breq	.+52     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
     400:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
     404:	00 91 d2 02 	lds	r16, 0x02D2	; 0x8002d2 <_ZL8lastshow>
     408:	10 91 d3 02 	lds	r17, 0x02D3	; 0x8002d3 <_ZL8lastshow+0x1>
     40c:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <_ZL8lastshow+0x2>
     410:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <_ZL8lastshow+0x3>
     414:	dc 01       	movw	r26, r24
     416:	cb 01       	movw	r24, r22
     418:	80 1b       	sub	r24, r16
     41a:	91 0b       	sbc	r25, r17
     41c:	a2 0b       	sbc	r26, r18
     41e:	b3 0b       	sbc	r27, r19
     420:	f7 01       	movw	r30, r14
     422:	03 81       	ldd	r16, Z+3	; 0x03
     424:	14 81       	ldd	r17, Z+4	; 0x04
     426:	25 81       	ldd	r18, Z+5	; 0x05
     428:	36 81       	ldd	r19, Z+6	; 0x06
     42a:	80 17       	cp	r24, r16
     42c:	91 07       	cpc	r25, r17
     42e:	a2 07       	cpc	r26, r18
     430:	b3 07       	cpc	r27, r19
     432:	e8 f2       	brcs	.-70     	; 0x3ee <_ZN8CFastLED9showColorERK4CRGBh+0x26>
     434:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
     438:	60 93 d2 02 	sts	0x02D2, r22	; 0x8002d2 <_ZL8lastshow>
     43c:	70 93 d3 02 	sts	0x02D3, r23	; 0x8002d3 <_ZL8lastshow+0x1>
     440:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <_ZL8lastshow+0x2>
     444:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <_ZL8lastshow+0x3>
     448:	d7 01       	movw	r26, r14
     44a:	1b 96       	adiw	r26, 0x0b	; 11
     44c:	ed 91       	ld	r30, X+
     44e:	fc 91       	ld	r31, X
     450:	1c 97       	sbiw	r26, 0x0c	; 12
     452:	30 97       	sbiw	r30, 0x00	; 0
     454:	51 f0       	breq	.+20     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     456:	d7 01       	movw	r26, r14
     458:	17 96       	adiw	r26, 0x07	; 7
     45a:	4d 91       	ld	r20, X+
     45c:	5d 91       	ld	r21, X+
     45e:	6d 91       	ld	r22, X+
     460:	7c 91       	ld	r23, X
     462:	1a 97       	sbiw	r26, 0x0a	; 10
     464:	8d 2d       	mov	r24, r13
     466:	09 95       	icall
     468:	d8 2e       	mov	r13, r24
     46a:	00 91 d8 02 	lds	r16, 0x02D8	; 0x8002d8 <_ZN14CLEDController7m_pHeadE>
     46e:	10 91 d9 02 	lds	r17, 0x02D9	; 0x8002d9 <_ZN14CLEDController7m_pHeadE+0x1>
     472:	01 15       	cp	r16, r1
     474:	11 05       	cpc	r17, r1
     476:	71 f1       	breq	.+92     	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
     478:	f8 01       	movw	r30, r16
     47a:	c4 84       	ldd	r12, Z+12	; 0x0c
     47c:	d7 01       	movw	r26, r14
     47e:	11 96       	adiw	r26, 0x01	; 1
     480:	8d 91       	ld	r24, X+
     482:	9c 91       	ld	r25, X
     484:	12 97       	sbiw	r26, 0x02	; 2
     486:	84 36       	cpi	r24, 0x64	; 100
     488:	91 05       	cpc	r25, r1
     48a:	08 f4       	brcc	.+2      	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
     48c:	14 86       	std	Z+12, r1	; 0x0c
     48e:	d8 01       	movw	r26, r16
     490:	ed 91       	ld	r30, X+
     492:	fc 91       	ld	r31, X
     494:	80 80       	ld	r8, Z
     496:	91 80       	ldd	r9, Z+1	; 0x01
     498:	98 01       	movw	r18, r16
     49a:	27 5f       	subi	r18, 0xF7	; 247
     49c:	3f 4f       	sbci	r19, 0xFF	; 255
     49e:	a8 01       	movw	r20, r16
     4a0:	4a 5f       	subi	r20, 0xFA	; 250
     4a2:	5f 4f       	sbci	r21, 0xFF	; 255
     4a4:	6d 2d       	mov	r22, r13
     4a6:	ce 01       	movw	r24, r28
     4a8:	01 96       	adiw	r24, 0x01	; 1
     4aa:	0e 94 74 00 	call	0xe8	; 0xe8 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>
     4ae:	f8 01       	movw	r30, r16
     4b0:	45 85       	ldd	r20, Z+13	; 0x0d
     4b2:	56 85       	ldd	r21, Z+14	; 0x0e
     4b4:	9e 01       	movw	r18, r28
     4b6:	2f 5f       	subi	r18, 0xFF	; 255
     4b8:	3f 4f       	sbci	r19, 0xFF	; 255
     4ba:	b5 01       	movw	r22, r10
     4bc:	c8 01       	movw	r24, r16
     4be:	f4 01       	movw	r30, r8
     4c0:	09 95       	icall
     4c2:	d8 01       	movw	r26, r16
     4c4:	1c 96       	adiw	r26, 0x0c	; 12
     4c6:	cc 92       	st	X, r12
     4c8:	1c 97       	sbiw	r26, 0x0c	; 12
     4ca:	14 96       	adiw	r26, 0x04	; 4
     4cc:	0d 91       	ld	r16, X+
     4ce:	1c 91       	ld	r17, X
     4d0:	15 97       	sbiw	r26, 0x05	; 5
     4d2:	cf cf       	rjmp	.-98     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
     4d4:	69 e1       	ldi	r22, 0x19	; 25
     4d6:	70 e0       	ldi	r23, 0x00	; 0
     4d8:	c7 01       	movw	r24, r14
     4da:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <_ZN8CFastLED8countFPSEi>
     4de:	0f 90       	pop	r0
     4e0:	0f 90       	pop	r0
     4e2:	0f 90       	pop	r0
     4e4:	df 91       	pop	r29
     4e6:	cf 91       	pop	r28
     4e8:	1f 91       	pop	r17
     4ea:	0f 91       	pop	r16
     4ec:	ff 90       	pop	r15
     4ee:	ef 90       	pop	r14
     4f0:	df 90       	pop	r13
     4f2:	cf 90       	pop	r12
     4f4:	bf 90       	pop	r11
     4f6:	af 90       	pop	r10
     4f8:	9f 90       	pop	r9
     4fa:	8f 90       	pop	r8
     4fc:	08 95       	ret

000004fe <_ZN8CFastLED5clearEb>:
     4fe:	0f 93       	push	r16
     500:	1f 93       	push	r17
     502:	cf 93       	push	r28
     504:	df 93       	push	r29
     506:	00 d0       	rcall	.+0      	; 0x508 <_ZN8CFastLED5clearEb+0xa>
     508:	1f 92       	push	r1
     50a:	cd b7       	in	r28, 0x3d	; 61
     50c:	de b7       	in	r29, 0x3e	; 62
     50e:	8c 01       	movw	r16, r24
     510:	66 23       	and	r22, r22
     512:	49 f0       	breq	.+18     	; 0x526 <_ZN8CFastLED5clearEb+0x28>
     514:	19 82       	std	Y+1, r1	; 0x01
     516:	1a 82       	std	Y+2, r1	; 0x02
     518:	1b 82       	std	Y+3, r1	; 0x03
     51a:	40 e0       	ldi	r20, 0x00	; 0
     51c:	be 01       	movw	r22, r28
     51e:	6f 5f       	subi	r22, 0xFF	; 255
     520:	7f 4f       	sbci	r23, 0xFF	; 255
     522:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN8CFastLED9showColorERK4CRGBh>
     526:	c8 01       	movw	r24, r16
     528:	0e 94 db 00 	call	0x1b6	; 0x1b6 <_ZN8CFastLED9clearDataEv>
     52c:	0f 90       	pop	r0
     52e:	0f 90       	pop	r0
     530:	0f 90       	pop	r0
     532:	df 91       	pop	r29
     534:	cf 91       	pop	r28
     536:	1f 91       	pop	r17
     538:	0f 91       	pop	r16
     53a:	08 95       	ret

0000053c <_ZN8CFastLED17setMaxRefreshRateEjb>:
     53c:	cf 93       	push	r28
     53e:	df 93       	push	r29
     540:	ec 01       	movw	r28, r24
     542:	44 23       	and	r20, r20
     544:	e1 f0       	breq	.+56     	; 0x57e <_ZN8CFastLED17setMaxRefreshRateEjb+0x42>
     546:	61 15       	cp	r22, r1
     548:	71 05       	cpc	r23, r1
     54a:	71 f1       	breq	.+92     	; 0x5a8 <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
     54c:	9b 01       	movw	r18, r22
     54e:	40 e0       	ldi	r20, 0x00	; 0
     550:	50 e0       	ldi	r21, 0x00	; 0
     552:	60 e4       	ldi	r22, 0x40	; 64
     554:	72 e4       	ldi	r23, 0x42	; 66
     556:	8f e0       	ldi	r24, 0x0F	; 15
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <__divmodsi4>
     55e:	8b 81       	ldd	r24, Y+3	; 0x03
     560:	9c 81       	ldd	r25, Y+4	; 0x04
     562:	ad 81       	ldd	r26, Y+5	; 0x05
     564:	be 81       	ldd	r27, Y+6	; 0x06
     566:	82 17       	cp	r24, r18
     568:	93 07       	cpc	r25, r19
     56a:	a4 07       	cpc	r26, r20
     56c:	b5 07       	cpc	r27, r21
     56e:	10 f4       	brcc	.+4      	; 0x574 <_ZN8CFastLED17setMaxRefreshRateEjb+0x38>
     570:	da 01       	movw	r26, r20
     572:	c9 01       	movw	r24, r18
     574:	8b 83       	std	Y+3, r24	; 0x03
     576:	9c 83       	std	Y+4, r25	; 0x04
     578:	ad 83       	std	Y+5, r26	; 0x05
     57a:	be 83       	std	Y+6, r27	; 0x06
     57c:	15 c0       	rjmp	.+42     	; 0x5a8 <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
     57e:	61 15       	cp	r22, r1
     580:	71 05       	cpc	r23, r1
     582:	71 f0       	breq	.+28     	; 0x5a0 <_ZN8CFastLED17setMaxRefreshRateEjb+0x64>
     584:	9b 01       	movw	r18, r22
     586:	40 e0       	ldi	r20, 0x00	; 0
     588:	50 e0       	ldi	r21, 0x00	; 0
     58a:	60 e4       	ldi	r22, 0x40	; 64
     58c:	72 e4       	ldi	r23, 0x42	; 66
     58e:	8f e0       	ldi	r24, 0x0F	; 15
     590:	90 e0       	ldi	r25, 0x00	; 0
     592:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <__divmodsi4>
     596:	2b 83       	std	Y+3, r18	; 0x03
     598:	3c 83       	std	Y+4, r19	; 0x04
     59a:	4d 83       	std	Y+5, r20	; 0x05
     59c:	5e 83       	std	Y+6, r21	; 0x06
     59e:	04 c0       	rjmp	.+8      	; 0x5a8 <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
     5a0:	1b 82       	std	Y+3, r1	; 0x03
     5a2:	1c 82       	std	Y+4, r1	; 0x04
     5a4:	1d 82       	std	Y+5, r1	; 0x05
     5a6:	1e 82       	std	Y+6, r1	; 0x06
     5a8:	df 91       	pop	r29
     5aa:	cf 91       	pop	r28
     5ac:	08 95       	ret

000005ae <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii>:
     5ae:	cf 92       	push	r12
     5b0:	df 92       	push	r13
     5b2:	ef 92       	push	r14
     5b4:	ff 92       	push	r15
     5b6:	0f 93       	push	r16
     5b8:	1f 93       	push	r17
     5ba:	cf 93       	push	r28
     5bc:	df 93       	push	r29
     5be:	8c 01       	movw	r16, r24
     5c0:	6b 01       	movw	r12, r22
     5c2:	ea 01       	movw	r28, r20
     5c4:	79 01       	movw	r14, r18
     5c6:	12 16       	cp	r1, r18
     5c8:	13 06       	cpc	r1, r19
     5ca:	1c f0       	brlt	.+6      	; 0x5d2 <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii+0x24>
     5cc:	7a 01       	movw	r14, r20
     5ce:	c0 e0       	ldi	r28, 0x00	; 0
     5d0:	d0 e0       	ldi	r29, 0x00	; 0
     5d2:	d8 01       	movw	r26, r16
     5d4:	ed 91       	ld	r30, X+
     5d6:	fc 91       	ld	r31, X
     5d8:	04 80       	ldd	r0, Z+4	; 0x04
     5da:	f5 81       	ldd	r31, Z+5	; 0x05
     5dc:	e0 2d       	mov	r30, r0
     5de:	c8 01       	movw	r24, r16
     5e0:	09 95       	icall
     5e2:	ce 01       	movw	r24, r28
     5e4:	88 0f       	add	r24, r24
     5e6:	99 1f       	adc	r25, r25
     5e8:	c8 0f       	add	r28, r24
     5ea:	d9 1f       	adc	r29, r25
     5ec:	cc 0d       	add	r28, r12
     5ee:	dd 1d       	adc	r29, r13
     5f0:	f8 01       	movw	r30, r16
     5f2:	d3 83       	std	Z+3, r29	; 0x03
     5f4:	c2 83       	std	Z+2, r28	; 0x02
     5f6:	f6 86       	std	Z+14, r15	; 0x0e
     5f8:	e5 86       	std	Z+13, r14	; 0x0d
     5fa:	01 90       	ld	r0, Z+
     5fc:	f0 81       	ld	r31, Z
     5fe:	e0 2d       	mov	r30, r0
     600:	02 84       	ldd	r0, Z+10	; 0x0a
     602:	f3 85       	ldd	r31, Z+11	; 0x0b
     604:	e0 2d       	mov	r30, r0
     606:	c8 01       	movw	r24, r16
     608:	09 95       	icall
     60a:	41 e0       	ldi	r20, 0x01	; 1
     60c:	bc 01       	movw	r22, r24
     60e:	8a ed       	ldi	r24, 0xDA	; 218
     610:	92 e0       	ldi	r25, 0x02	; 2
     612:	0e 94 9e 02 	call	0x53c	; 0x53c <_ZN8CFastLED17setMaxRefreshRateEjb>
     616:	c8 01       	movw	r24, r16
     618:	df 91       	pop	r29
     61a:	cf 91       	pop	r28
     61c:	1f 91       	pop	r17
     61e:	0f 91       	pop	r16
     620:	ff 90       	pop	r15
     622:	ef 90       	pop	r14
     624:	df 90       	pop	r13
     626:	cf 90       	pop	r12
     628:	08 95       	ret

0000062a <_GLOBAL__sub_I_pSmartMatrix>:
     62a:	8a ed       	ldi	r24, 0xDA	; 218
     62c:	92 e0       	ldi	r25, 0x02	; 2
     62e:	0c 94 cc 00 	jmp	0x198	; 0x198 <_ZN8CFastLEDC1Ev>

00000632 <memset8>:
     632:	dc 01       	movw	r26, r24
     634:	40 ff       	sbrs	r20, 0
     636:	03 c0       	rjmp	.+6      	; 0x63e <Lseteven_8>
     638:	01 c0       	rjmp	.+2      	; 0x63c <Lsetodd_8>

0000063a <Lsetloop_8>:
     63a:	6d 93       	st	X+, r22

0000063c <Lsetodd_8>:
     63c:	6d 93       	st	X+, r22

0000063e <Lseteven_8>:
     63e:	42 50       	subi	r20, 0x02	; 2
     640:	e0 f7       	brcc	.-8      	; 0x63a <Lsetloop_8>
     642:	50 40       	sbci	r21, 0x00	; 0
     644:	d0 f7       	brcc	.-12     	; 0x63a <Lsetloop_8>
     646:	08 95       	ret

00000648 <_ZN14CLEDController4sizeEv>:
              }

              return adj;
      #endif
    }
    virtual uint16_t getMaxRefreshRate() const { return 0; }
     648:	fc 01       	movw	r30, r24
     64a:	85 85       	ldd	r24, Z+13	; 0x0d
     64c:	96 85       	ldd	r25, Z+14	; 0x0e
     64e:	08 95       	ret

00000650 <_ZN14CLEDController9clearLedsEi>:
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	00 d0       	rcall	.+0      	; 0x656 <_ZN14CLEDController9clearLedsEi+0x6>
     656:	00 d0       	rcall	.+0      	; 0x658 <_ZN14CLEDController9clearLedsEi+0x8>
     658:	00 d0       	rcall	.+0      	; 0x65a <_ZN14CLEDController9clearLedsEi+0xa>
     65a:	cd b7       	in	r28, 0x3d	; 61
     65c:	de b7       	in	r29, 0x3e	; 62
     65e:	ab 01       	movw	r20, r22
     660:	1c 82       	std	Y+4, r1	; 0x04
     662:	1d 82       	std	Y+5, r1	; 0x05
     664:	1e 82       	std	Y+6, r1	; 0x06
     666:	dc 01       	movw	r26, r24
     668:	ed 91       	ld	r30, X+
     66a:	fc 91       	ld	r31, X
     66c:	01 90       	ld	r0, Z+
     66e:	f0 81       	ld	r31, Z
     670:	e0 2d       	mov	r30, r0
     672:	19 82       	std	Y+1, r1	; 0x01
     674:	1a 82       	std	Y+2, r1	; 0x02
     676:	1b 82       	std	Y+3, r1	; 0x03
     678:	9e 01       	movw	r18, r28
     67a:	2f 5f       	subi	r18, 0xFF	; 255
     67c:	3f 4f       	sbci	r19, 0xFF	; 255
     67e:	be 01       	movw	r22, r28
     680:	6c 5f       	subi	r22, 0xFC	; 252
     682:	7f 4f       	sbci	r23, 0xFF	; 255
     684:	09 95       	icall
     686:	26 96       	adiw	r28, 0x06	; 6
     688:	0f b6       	in	r0, 0x3f	; 63
     68a:	f8 94       	cli
     68c:	de bf       	out	0x3e, r29	; 62
     68e:	0f be       	out	0x3f, r0	; 63
     690:	cd bf       	out	0x3d, r28	; 61
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	08 95       	ret

00000698 <_ZNK19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE17getMaxRefreshRateEv>:
public:
	virtual void init() {
		FastPin<DATA_PIN>::setOutput();
	}

	virtual uint16_t getMaxRefreshRate() const { return 400; }
     698:	80 e9       	ldi	r24, 0x90	; 144
     69a:	91 e0       	ldi	r25, 0x01	; 1
     69c:	08 95       	ret

0000069e <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE4initEv>:
template<uint8_t PIN, uint8_t _MASK, typename _PORT, typename _DDR, typename _PIN> class _AVRPIN {
public:
	typedef volatile uint8_t * port_ptr_t;
	typedef uint8_t port_t;

	inline static void setOutput() { _DDR::r() |= _MASK; }
     69e:	53 9a       	sbi	0x0a, 3	; 10
     6a0:	08 95       	ret

000006a2 <_ZN8CFastLED4showEv>:
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
     6a2:	fc 01       	movw	r30, r24
     6a4:	60 81       	ld	r22, Z
     6a6:	0c 94 4d 01 	jmp	0x29a	; 0x29a <_ZN8CFastLED4showEh>

000006aa <setup>:
#define DATA_PIN 3

CRGB leds[NUM_LEDS];

void setup() {
  delay(2000);
     6aa:	60 ed       	ldi	r22, 0xD0	; 208
     6ac:	77 e0       	ldi	r23, 0x07	; 7
     6ae:	80 e0       	ldi	r24, 0x00	; 0
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
     6b6:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <_ZGVZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c>
     6ba:	81 11       	cpse	r24, r1
     6bc:	45 c0       	rjmp	.+138    	; 0x748 <setup+0x9e>
	///@param scale the rgb scaling to apply to each led before writing it out
    virtual void show(const struct CRGB *data, int nLeds, CRGB scale) = 0;

public:
	/// create an led controller object, add it to the chain of controllers
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
     6be:	10 92 f3 02 	sts	0x02F3, r1	; 0x8002f3 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x3>
     6c2:	10 92 f2 02 	sts	0x02F2, r1	; 0x8002f2 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x2>
    {
    }

    /// allow construction from a LEDColorCorrection enum
    inline CRGB( LEDColorCorrection colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     6c6:	8f ef       	ldi	r24, 0xFF	; 255
     6c8:	80 93 f6 02 	sts	0x02F6, r24	; 0x8002f6 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x6>
     6cc:	80 93 f7 02 	sts	0x02F7, r24	; 0x8002f7 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x7>
     6d0:	80 93 f8 02 	sts	0x02F8, r24	; 0x8002f8 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x8>

    }

    /// allow construction from a ColorTemperature enum
    inline CRGB( ColorTemperature colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     6d4:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x9>
     6d8:	80 93 fa 02 	sts	0x02FA, r24	; 0x8002fa <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0xa>
     6dc:	80 93 fb 02 	sts	0x02FB, r24	; 0x8002fb <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0xb>
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0xc>
     6e6:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0xe>
     6ea:	10 92 fd 02 	sts	0x02FD, r1	; 0x8002fd <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0xd>
        m_pNext = NULL;
     6ee:	10 92 f5 02 	sts	0x02F5, r1	; 0x8002f5 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x5>
     6f2:	10 92 f4 02 	sts	0x02F4, r1	; 0x8002f4 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x4>
        if(m_pHead==NULL) { m_pHead = this; }
     6f6:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <_ZN14CLEDController7m_pHeadE>
     6fa:	90 91 d9 02 	lds	r25, 0x02D9	; 0x8002d9 <_ZN14CLEDController7m_pHeadE+0x1>
     6fe:	89 2b       	or	r24, r25
     700:	31 f4       	brne	.+12     	; 0x70e <setup+0x64>
     702:	80 ef       	ldi	r24, 0xF0	; 240
     704:	92 e0       	ldi	r25, 0x02	; 2
     706:	90 93 d9 02 	sts	0x02D9, r25	; 0x8002d9 <_ZN14CLEDController7m_pHeadE+0x1>
     70a:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <_ZN14CLEDController7m_pHeadE>
        if(m_pTail != NULL) { m_pTail->m_pNext = this; }
     70e:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <_ZN14CLEDController7m_pTailE>
     712:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <_ZN14CLEDController7m_pTailE+0x1>
     716:	30 97       	sbiw	r30, 0x00	; 0
     718:	21 f0       	breq	.+8      	; 0x722 <setup+0x78>
     71a:	80 ef       	ldi	r24, 0xF0	; 240
     71c:	92 e0       	ldi	r25, 0x02	; 2
     71e:	95 83       	std	Z+5, r25	; 0x05
     720:	84 83       	std	Z+4, r24	; 0x04
        m_pTail = this;
     722:	80 ef       	ldi	r24, 0xF0	; 240
     724:	92 e0       	ldi	r25, 0x02	; 2
     726:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <_ZN14CLEDController7m_pTailE+0x1>
     72a:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <_ZN14CLEDController7m_pTailE>
/// Class to ensure that a minimum amount of time has kicked since the last time run - and delay if not enough time has passed yet
/// this should make sure that chipsets that have
template<int WAIT> class CMinWait {
	uint16_t mLastMicros;
public:
	CMinWait() { mLastMicros = 0; }
     72e:	10 92 00 03 	sts	0x0300, r1	; 0x800300 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x10>
     732:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0xf>
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812B : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class SK6812 : public SK6812Controller<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class SK6822 : public SK6822Controller<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class APA106 : public SK6822Controller<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class PL9823 : public PL9823Controller<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2811 : public WS2811Controller800Khz<DATA_PIN, RGB_ORDER> {};
     736:	8e eb       	ldi	r24, 0xBE	; 190
     738:	92 e0       	ldi	r25, 0x02	; 2
     73a:	90 93 f1 02 	sts	0x02F1, r25	; 0x8002f1 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c+0x1>
     73e:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <_ZZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c>
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
     742:	81 e0       	ldi	r24, 0x01	; 1
     744:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <_ZGVZN8CFastLED7addLedsI6WS2811Lh3EL6EOrder10EEER14CLEDControllerP4CRGBiiE1c>
		return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	44 ec       	ldi	r20, 0xC4	; 196
     74e:	50 e0       	ldi	r21, 0x00	; 0
     750:	61 e0       	ldi	r22, 0x01	; 1
     752:	73 e0       	ldi	r23, 0x03	; 3
     754:	80 ef       	ldi	r24, 0xF0	; 240
     756:	92 e0       	ldi	r25, 0x02	; 2
     758:	0e 94 d7 02 	call	0x5ae	; 0x5ae <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii>
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
     75c:	88 e2       	ldi	r24, 0x28	; 40
     75e:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <FastLED>
  FastLED.addLeds<WS2811, DATA_PIN, RGB>(leds, NUM_LEDS);
  FastLED.setBrightness(40); //Number 0-255
  FastLED.clear();
     762:	60 e0       	ldi	r22, 0x00	; 0
     764:	8a ed       	ldi	r24, 0xDA	; 218
     766:	92 e0       	ldi	r25, 0x02	; 2
     768:	0c 94 7f 02 	jmp	0x4fe	; 0x4fe <_ZN8CFastLED5clearEb>

0000076c <loop>:
unsigned char pacg_ph4_body[] = {133, 134};
int pac_girl_loop = 20;



void loop() {
     76c:	2f 92       	push	r2
     76e:	3f 92       	push	r3
     770:	4f 92       	push	r4
     772:	5f 92       	push	r5
     774:	6f 92       	push	r6
     776:	7f 92       	push	r7
     778:	8f 92       	push	r8
     77a:	9f 92       	push	r9
     77c:	af 92       	push	r10
     77e:	bf 92       	push	r11
     780:	cf 92       	push	r12
     782:	df 92       	push	r13
     784:	ef 92       	push	r14
     786:	ff 92       	push	r15
     788:	0f 93       	push	r16
     78a:	1f 93       	push	r17
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	00 d0       	rcall	.+0      	; 0x792 <loop+0x26>
     792:	00 d0       	rcall	.+0      	; 0x794 <loop+0x28>
     794:	1f 92       	push	r1
     796:	cd b7       	in	r28, 0x3d	; 61
     798:	de b7       	in	r29, 0x3e	; 62
	int i,j,k;
	
	FastLED.clear();
     79a:	60 e0       	ldi	r22, 0x00	; 0
     79c:	8a ed       	ldi	r24, 0xDA	; 218
     79e:	92 e0       	ldi	r25, 0x02	; 2
     7a0:	0e 94 7f 02 	call	0x4fe	; 0x4fe <_ZN8CFastLED5clearEb>
	
    for(int k = 0; k < reg_ghost_loop; k++){
     7a4:	e1 2c       	mov	r14, r1
     7a6:	f1 2c       	mov	r15, r1
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     7a8:	1f ef       	ldi	r17, 0xFF	; 255
     7aa:	0f ef       	ldi	r16, 0xFF	; 255
     7ac:	e0 ea       	ldi	r30, 0xA0	; 160
     7ae:	2e 2e       	mov	r2, r30
     7b0:	e2 e0       	ldi	r30, 0x02	; 2
     7b2:	3e 2e       	mov	r3, r30
     7b4:	f8 e7       	ldi	r31, 0x78	; 120
     7b6:	4f 2e       	mov	r4, r31
     7b8:	f2 e0       	ldi	r31, 0x02	; 2
     7ba:	5f 2e       	mov	r5, r31
     7bc:	80 91 40 02 	lds	r24, 0x0240	; 0x800240 <reg_ghost_loop>
     7c0:	90 91 41 02 	lds	r25, 0x0241	; 0x800241 <reg_ghost_loop+0x1>
     7c4:	e8 16       	cp	r14, r24
     7c6:	f9 06       	cpc	r15, r25
     7c8:	1c f4       	brge	.+6      	; 0x7d0 <loop+0x64>
     7ca:	c1 2c       	mov	r12, r1
     7cc:	d1 2c       	mov	r13, r1
     7ce:	24 c0       	rjmp	.+72     	; 0x818 <loop+0xac>
     7d0:	00 e0       	ldi	r16, 0x00	; 0
     7d2:	10 e0       	ldi	r17, 0x00	; 0
     7d4:	4b e8       	ldi	r20, 0x8B	; 139
     7d6:	44 2e       	mov	r4, r20
     7d8:	5a eb       	ldi	r21, 0xBA	; 186
     7da:	65 2e       	mov	r6, r21
     7dc:	52 e0       	ldi	r21, 0x02	; 2
     7de:	75 2e       	mov	r7, r21
     7e0:	6a e5       	ldi	r22, 0x5A	; 90
     7e2:	a6 2e       	mov	r10, r22
     7e4:	62 e0       	ldi	r22, 0x02	; 2
     7e6:	b6 2e       	mov	r11, r22
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     7e8:	55 24       	eor	r5, r5
     7ea:	5a 94       	dec	r5
     7ec:	70 e7       	ldi	r23, 0x70	; 112
     7ee:	87 2e       	mov	r8, r23
     7f0:	72 e0       	ldi	r23, 0x02	; 2
     7f2:	97 2e       	mov	r9, r23
     7f4:	23 c2       	rjmp	.+1094   	; 0xc3c <__stack+0x33d>
            //remove around feet (v2)
            for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
                leds[zoid_void_pixels_2[i]] = CRGB::Black;
            }
        
            FastLED.show();
     7f6:	8a ed       	ldi	r24, 0xDA	; 218
     7f8:	92 e0       	ldi	r25, 0x02	; 2
     7fa:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
        
            delay(feet_delay);
     7fe:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     802:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     806:	07 2e       	mov	r0, r23
     808:	00 0c       	add	r0, r0
     80a:	88 0b       	sbc	r24, r24
     80c:	99 0b       	sbc	r25, r25
     80e:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
	
	FastLED.clear();
	
    for(int k = 0; k < reg_ghost_loop; k++){

        for(j = 0; j < eye_loop; j++){				// looking left
     812:	ff ef       	ldi	r31, 0xFF	; 255
     814:	cf 1a       	sub	r12, r31
     816:	df 0a       	sbc	r13, r31
     818:	80 91 42 02 	lds	r24, 0x0242	; 0x800242 <eye_loop>
     81c:	90 91 43 02 	lds	r25, 0x0243	; 0x800243 <eye_loop+0x1>
     820:	c8 16       	cp	r12, r24
     822:	d9 06       	cpc	r13, r25
     824:	1c f0       	brlt	.+6      	; 0x82c <loop+0xc0>
     826:	c1 2c       	mov	r12, r1
     828:	d1 2c       	mov	r13, r1
     82a:	02 c1       	rjmp	.+516    	; 0xa30 <__stack+0x131>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     82c:	09 83       	std	Y+1, r16	; 0x01
     82e:	1a 82       	std	Y+2, r1	; 0x02
     830:	1b 82       	std	Y+3, r1	; 0x03

            //fill body
            fill_solid(leds, NUM_LEDS, CRGB::Red);
     832:	ae 01       	movw	r20, r28
     834:	4f 5f       	subi	r20, 0xFF	; 255
     836:	5f 4f       	sbci	r21, 0xFF	; 255
     838:	64 ec       	ldi	r22, 0xC4	; 196
     83a:	70 e0       	ldi	r23, 0x00	; 0
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	93 e0       	ldi	r25, 0x03	; 3
     840:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
     844:	30 ea       	ldi	r19, 0xA0	; 160
     846:	63 2e       	mov	r6, r19
     848:	32 e0       	ldi	r19, 0x02	; 2
     84a:	73 2e       	mov	r7, r19
     84c:	d3 01       	movw	r26, r6
			
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     84e:	22 e0       	ldi	r18, 0x02	; 2
     850:	aa 3b       	cpi	r26, 0xBA	; 186
     852:	b2 07       	cpc	r27, r18
     854:	69 f0       	breq	.+26     	; 0x870 <loop+0x104>
				leds[zoid_always_black[i]] = CRGB::Black;
     856:	ed 91       	ld	r30, X+
     858:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     85a:	cf 01       	movw	r24, r30
     85c:	88 0f       	add	r24, r24
     85e:	99 1f       	adc	r25, r25
     860:	e8 0f       	add	r30, r24
     862:	f9 1f       	adc	r31, r25
     864:	ef 5f       	subi	r30, 0xFF	; 255
     866:	fc 4f       	sbci	r31, 0xFC	; 252
     868:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     86a:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     86c:	12 82       	std	Z+2, r1	; 0x02

            //fill body
            fill_solid(leds, NUM_LEDS, CRGB::Red);
			
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     86e:	ef cf       	rjmp	.-34     	; 0x84e <loop+0xe2>
     870:	70 e9       	ldi	r23, 0x90	; 144
     872:	87 2e       	mov	r8, r23
     874:	72 e0       	ldi	r23, 0x02	; 2
     876:	97 2e       	mov	r9, r23
     878:	80 e8       	ldi	r24, 0x80	; 128
     87a:	92 e0       	ldi	r25, 0x02	; 2
     87c:	9d 83       	std	Y+5, r25	; 0x05
     87e:	8c 83       	std	Y+4, r24	; 0x04
     880:	d4 01       	movw	r26, r8
				leds[zoid_always_black[i]] = CRGB::Black;
			}       
            //set white pixels eyes 
            for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     882:	e2 e0       	ldi	r30, 0x02	; 2
     884:	a0 3a       	cpi	r26, 0xA0	; 160
     886:	be 07       	cpc	r27, r30
     888:	e1 f0       	breq	.+56     	; 0x8c2 <loop+0x156>
                leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
     88a:	ed 91       	ld	r30, X+
     88c:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     88e:	9f 01       	movw	r18, r30
     890:	22 0f       	add	r18, r18
     892:	33 1f       	adc	r19, r19
     894:	e2 0f       	add	r30, r18
     896:	f3 1f       	adc	r31, r19
     898:	ef 5f       	subi	r30, 0xFF	; 255
     89a:	fc 4f       	sbci	r31, 0xFC	; 252
     89c:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     89e:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     8a0:	12 83       	std	Z+2, r17	; 0x02
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
     8a2:	fc 01       	movw	r30, r24
     8a4:	21 91       	ld	r18, Z+
     8a6:	cf 01       	movw	r24, r30
     8a8:	e2 2f       	mov	r30, r18
     8aa:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     8ac:	9f 01       	movw	r18, r30
     8ae:	22 0f       	add	r18, r18
     8b0:	33 1f       	adc	r19, r19
     8b2:	e2 0f       	add	r30, r18
     8b4:	f3 1f       	adc	r31, r19
     8b6:	ef 5f       	subi	r30, 0xFF	; 255
     8b8:	fc 4f       	sbci	r31, 0xFC	; 252
     8ba:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     8bc:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     8be:	12 83       	std	Z+2, r17	; 0x02
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
				leds[zoid_always_black[i]] = CRGB::Black;
			}       
            //set white pixels eyes 
            for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     8c0:	e0 cf       	rjmp	.-64     	; 0x882 <loop+0x116>
     8c2:	48 e7       	ldi	r20, 0x78	; 120
     8c4:	a4 2e       	mov	r10, r20
     8c6:	42 e0       	ldi	r20, 0x02	; 2
     8c8:	b4 2e       	mov	r11, r20
     8ca:	d5 01       	movw	r26, r10
                leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
            }
            
            //set pupil
            for (int i = 0; i < sizeof(zoid_pupils_l); i++){
     8cc:	80 e8       	ldi	r24, 0x80	; 128
     8ce:	92 e0       	ldi	r25, 0x02	; 2
     8d0:	8a 17       	cp	r24, r26
     8d2:	9b 07       	cpc	r25, r27
     8d4:	71 f0       	breq	.+28     	; 0x8f2 <loop+0x186>
                leds[zoid_pupils_l[i]] = CRGB::DarkBlue;
     8d6:	ed 91       	ld	r30, X+
     8d8:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     8da:	cf 01       	movw	r24, r30
     8dc:	88 0f       	add	r24, r24
     8de:	99 1f       	adc	r25, r25
     8e0:	e8 0f       	add	r30, r24
     8e2:	f9 1f       	adc	r31, r25
     8e4:	ef 5f       	subi	r30, 0xFF	; 255
     8e6:	fc 4f       	sbci	r31, 0xFC	; 252
     8e8:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     8ea:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     8ec:	9b e8       	ldi	r25, 0x8B	; 139
     8ee:	92 83       	std	Z+2, r25	; 0x02
                leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
            }
            
            //set pupil
            for (int i = 0; i < sizeof(zoid_pupils_l); i++){
     8f0:	ed cf       	rjmp	.-38     	; 0x8cc <loop+0x160>
     8f2:	a4 e6       	ldi	r26, 0x64	; 100
     8f4:	b2 e0       	ldi	r27, 0x02	; 2
                leds[zoid_pupils_l[i]] = CRGB::DarkBlue;
            }
            //remove around feet (v1)
            for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     8f6:	e2 e0       	ldi	r30, 0x02	; 2
     8f8:	a0 37       	cpi	r26, 0x70	; 112
     8fa:	be 07       	cpc	r27, r30
     8fc:	69 f0       	breq	.+26     	; 0x918 <__stack+0x19>
                leds[zoid_void_pixels_1[i]] = CRGB::Black;
     8fe:	ed 91       	ld	r30, X+
     900:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     902:	cf 01       	movw	r24, r30
     904:	88 0f       	add	r24, r24
     906:	99 1f       	adc	r25, r25
     908:	e8 0f       	add	r30, r24
     90a:	f9 1f       	adc	r31, r25
     90c:	ef 5f       	subi	r30, 0xFF	; 255
     90e:	fc 4f       	sbci	r31, 0xFC	; 252
     910:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     912:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     914:	12 82       	std	Z+2, r1	; 0x02
            //set pupil
            for (int i = 0; i < sizeof(zoid_pupils_l); i++){
                leds[zoid_pupils_l[i]] = CRGB::DarkBlue;
            }
            //remove around feet (v1)
            for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     916:	ef cf       	rjmp	.-34     	; 0x8f6 <loop+0x18a>
                leds[zoid_void_pixels_1[i]] = CRGB::Black;
            }
            FastLED.show();
     918:	8a ed       	ldi	r24, 0xDA	; 218
     91a:	92 e0       	ldi	r25, 0x02	; 2
     91c:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
        
            delay(feet_delay);
     920:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     924:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     928:	07 2e       	mov	r0, r23
     92a:	00 0c       	add	r0, r0
     92c:	88 0b       	sbc	r24, r24
     92e:	99 0b       	sbc	r25, r25
     930:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     934:	09 83       	std	Y+1, r16	; 0x01
     936:	1a 82       	std	Y+2, r1	; 0x02
     938:	1b 82       	std	Y+3, r1	; 0x03

			//fill body
			fill_solid(leds, NUM_LEDS, CRGB::Red);
     93a:	ae 01       	movw	r20, r28
     93c:	4f 5f       	subi	r20, 0xFF	; 255
     93e:	5f 4f       	sbci	r21, 0xFF	; 255
     940:	64 ec       	ldi	r22, 0xC4	; 196
     942:	70 e0       	ldi	r23, 0x00	; 0
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	93 e0       	ldi	r25, 0x03	; 3
     948:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
			            
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     94c:	fa eb       	ldi	r31, 0xBA	; 186
     94e:	6f 16       	cp	r6, r31
     950:	f2 e0       	ldi	r31, 0x02	; 2
     952:	7f 06       	cpc	r7, r31
     954:	79 f0       	breq	.+30     	; 0x974 <__stack+0x75>
				leds[zoid_always_black[i]] = CRGB::Black;
     956:	d3 01       	movw	r26, r6
     958:	ed 91       	ld	r30, X+
     95a:	3d 01       	movw	r6, r26
     95c:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     95e:	cf 01       	movw	r24, r30
     960:	88 0f       	add	r24, r24
     962:	99 1f       	adc	r25, r25
     964:	e8 0f       	add	r30, r24
     966:	f9 1f       	adc	r31, r25
     968:	ef 5f       	subi	r30, 0xFF	; 255
     96a:	fc 4f       	sbci	r31, 0xFC	; 252
     96c:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     96e:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     970:	12 82       	std	Z+2, r1	; 0x02

			//fill body
			fill_solid(leds, NUM_LEDS, CRGB::Red);
			            
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     972:	ec cf       	rjmp	.-40     	; 0x94c <__stack+0x4d>
				leds[zoid_always_black[i]] = CRGB::Black;
			}
			//set white pixels eyes
			for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     974:	b0 ea       	ldi	r27, 0xA0	; 160
     976:	8b 16       	cp	r8, r27
     978:	b2 e0       	ldi	r27, 0x02	; 2
     97a:	9b 06       	cpc	r9, r27
     97c:	f9 f0       	breq	.+62     	; 0x9bc <__stack+0xbd>
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
     97e:	d4 01       	movw	r26, r8
     980:	ed 91       	ld	r30, X+
     982:	4d 01       	movw	r8, r26
     984:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     986:	cf 01       	movw	r24, r30
     988:	88 0f       	add	r24, r24
     98a:	99 1f       	adc	r25, r25
     98c:	e8 0f       	add	r30, r24
     98e:	f9 1f       	adc	r31, r25
     990:	ef 5f       	subi	r30, 0xFF	; 255
     992:	fc 4f       	sbci	r31, 0xFC	; 252
     994:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     996:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     998:	12 83       	std	Z+2, r17	; 0x02
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
     99a:	ac 81       	ldd	r26, Y+4	; 0x04
     99c:	bd 81       	ldd	r27, Y+5	; 0x05
     99e:	ed 91       	ld	r30, X+
     9a0:	bd 83       	std	Y+5, r27	; 0x05
     9a2:	ac 83       	std	Y+4, r26	; 0x04
     9a4:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     9a6:	cf 01       	movw	r24, r30
     9a8:	88 0f       	add	r24, r24
     9aa:	99 1f       	adc	r25, r25
     9ac:	e8 0f       	add	r30, r24
     9ae:	f9 1f       	adc	r31, r25
     9b0:	ef 5f       	subi	r30, 0xFF	; 255
     9b2:	fc 4f       	sbci	r31, 0xFC	; 252
     9b4:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     9b6:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     9b8:	12 83       	std	Z+2, r17	; 0x02
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
				leds[zoid_always_black[i]] = CRGB::Black;
			}
			//set white pixels eyes
			for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     9ba:	dc cf       	rjmp	.-72     	; 0x974 <__stack+0x75>
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
			}
			            
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_l); i++){
     9bc:	e0 e8       	ldi	r30, 0x80	; 128
     9be:	f2 e0       	ldi	r31, 0x02	; 2
     9c0:	ea 15       	cp	r30, r10
     9c2:	fb 05       	cpc	r31, r11
     9c4:	81 f0       	breq	.+32     	; 0x9e6 <__stack+0xe7>
				leds[zoid_pupils_l[i]] = CRGB::DarkBlue;
     9c6:	d5 01       	movw	r26, r10
     9c8:	ed 91       	ld	r30, X+
     9ca:	5d 01       	movw	r10, r26
     9cc:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     9ce:	cf 01       	movw	r24, r30
     9d0:	88 0f       	add	r24, r24
     9d2:	99 1f       	adc	r25, r25
     9d4:	e8 0f       	add	r30, r24
     9d6:	f9 1f       	adc	r31, r25
     9d8:	ef 5f       	subi	r30, 0xFF	; 255
     9da:	fc 4f       	sbci	r31, 0xFC	; 252
     9dc:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     9de:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     9e0:	bb e8       	ldi	r27, 0x8B	; 139
     9e2:	b2 83       	std	Z+2, r27	; 0x02
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
			}
			            
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_l); i++){
     9e4:	eb cf       	rjmp	.-42     	; 0x9bc <__stack+0xbd>
     9e6:	aa e5       	ldi	r26, 0x5A	; 90
     9e8:	b2 e0       	ldi	r27, 0x02	; 2
				leds[zoid_pupils_l[i]] = CRGB::DarkBlue;
			}           
          
            //remove around feet (v2)
            for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     9ea:	e2 e0       	ldi	r30, 0x02	; 2
     9ec:	a4 36       	cpi	r26, 0x64	; 100
     9ee:	be 07       	cpc	r27, r30
     9f0:	09 f4       	brne	.+2      	; 0x9f4 <__stack+0xf5>
     9f2:	01 cf       	rjmp	.-510    	; 0x7f6 <loop+0x8a>
                leds[zoid_void_pixels_2[i]] = CRGB::Black;
     9f4:	ed 91       	ld	r30, X+
     9f6:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     9f8:	cf 01       	movw	r24, r30
     9fa:	88 0f       	add	r24, r24
     9fc:	99 1f       	adc	r25, r25
     9fe:	e8 0f       	add	r30, r24
     a00:	f9 1f       	adc	r31, r25
     a02:	ef 5f       	subi	r30, 0xFF	; 255
     a04:	fc 4f       	sbci	r31, 0xFC	; 252
     a06:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     a08:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     a0a:	12 82       	std	Z+2, r1	; 0x02
			for (int i = 0; i < sizeof(zoid_pupils_l); i++){
				leds[zoid_pupils_l[i]] = CRGB::DarkBlue;
			}           
          
            //remove around feet (v2)
            for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     a0c:	ee cf       	rjmp	.-36     	; 0x9ea <__stack+0xeb>
			//remove around feet (v2)
			for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
				leds[zoid_void_pixels_2[i]] = CRGB::Black;
			}
		
			FastLED.show();
     a0e:	8a ed       	ldi	r24, 0xDA	; 218
     a10:	92 e0       	ldi	r25, 0x02	; 2
     a12:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		
			delay(feet_delay);
     a16:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     a1a:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     a1e:	07 2e       	mov	r0, r23
     a20:	00 0c       	add	r0, r0
     a22:	88 0b       	sbc	r24, r24
     a24:	99 0b       	sbc	r25, r25
     a26:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
        
            delay(feet_delay);

        }

        for(j = 0; j < eye_loop; j++){			// looking right
     a2a:	ff ef       	ldi	r31, 0xFF	; 255
     a2c:	cf 1a       	sub	r12, r31
     a2e:	df 0a       	sbc	r13, r31
     a30:	80 91 42 02 	lds	r24, 0x0242	; 0x800242 <eye_loop>
     a34:	90 91 43 02 	lds	r25, 0x0243	; 0x800243 <eye_loop+0x1>
     a38:	c8 16       	cp	r12, r24
     a3a:	d9 06       	cpc	r13, r25
     a3c:	0c f0       	brlt	.+2      	; 0xa40 <__stack+0x141>
     a3e:	ea c0       	rjmp	.+468    	; 0xc14 <__stack+0x315>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     a40:	09 83       	std	Y+1, r16	; 0x01
     a42:	1a 82       	std	Y+2, r1	; 0x02
     a44:	1b 82       	std	Y+3, r1	; 0x03
        
			//fill body
			fill_solid(leds, NUM_LEDS, CRGB::Red);
     a46:	ae 01       	movw	r20, r28
     a48:	4f 5f       	subi	r20, 0xFF	; 255
     a4a:	5f 4f       	sbci	r21, 0xFF	; 255
     a4c:	64 ec       	ldi	r22, 0xC4	; 196
     a4e:	70 e0       	ldi	r23, 0x00	; 0
     a50:	81 e0       	ldi	r24, 0x01	; 1
     a52:	93 e0       	ldi	r25, 0x03	; 3
     a54:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
     a58:	30 ea       	ldi	r19, 0xA0	; 160
     a5a:	63 2e       	mov	r6, r19
     a5c:	32 e0       	ldi	r19, 0x02	; 2
     a5e:	73 2e       	mov	r7, r19
     a60:	d3 01       	movw	r26, r6
		
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     a62:	22 e0       	ldi	r18, 0x02	; 2
     a64:	aa 3b       	cpi	r26, 0xBA	; 186
     a66:	b2 07       	cpc	r27, r18
     a68:	69 f0       	breq	.+26     	; 0xa84 <__stack+0x185>
				leds[zoid_always_black[i]] = CRGB::Black;
     a6a:	ed 91       	ld	r30, X+
     a6c:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     a6e:	cf 01       	movw	r24, r30
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	e8 0f       	add	r30, r24
     a76:	f9 1f       	adc	r31, r25
     a78:	ef 5f       	subi	r30, 0xFF	; 255
     a7a:	fc 4f       	sbci	r31, 0xFC	; 252
     a7c:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     a7e:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     a80:	12 82       	std	Z+2, r1	; 0x02
        
			//fill body
			fill_solid(leds, NUM_LEDS, CRGB::Red);
		
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     a82:	ef cf       	rjmp	.-34     	; 0xa62 <__stack+0x163>
     a84:	70 e9       	ldi	r23, 0x90	; 144
     a86:	87 2e       	mov	r8, r23
     a88:	72 e0       	ldi	r23, 0x02	; 2
     a8a:	97 2e       	mov	r9, r23
     a8c:	80 e8       	ldi	r24, 0x80	; 128
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	9d 83       	std	Y+5, r25	; 0x05
     a92:	8c 83       	std	Y+4, r24	; 0x04
     a94:	d4 01       	movw	r26, r8
				leds[zoid_always_black[i]] = CRGB::Black;
			}
			//set white pixels eyes
			for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     a96:	2a 16       	cp	r2, r26
     a98:	3b 06       	cpc	r3, r27
     a9a:	e1 f0       	breq	.+56     	; 0xad4 <__stack+0x1d5>
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
     a9c:	ed 91       	ld	r30, X+
     a9e:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     aa0:	9f 01       	movw	r18, r30
     aa2:	22 0f       	add	r18, r18
     aa4:	33 1f       	adc	r19, r19
     aa6:	e2 0f       	add	r30, r18
     aa8:	f3 1f       	adc	r31, r19
     aaa:	ef 5f       	subi	r30, 0xFF	; 255
     aac:	fc 4f       	sbci	r31, 0xFC	; 252
     aae:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     ab0:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     ab2:	12 83       	std	Z+2, r17	; 0x02
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
     ab4:	fc 01       	movw	r30, r24
     ab6:	21 91       	ld	r18, Z+
     ab8:	cf 01       	movw	r24, r30
     aba:	e2 2f       	mov	r30, r18
     abc:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     abe:	9f 01       	movw	r18, r30
     ac0:	22 0f       	add	r18, r18
     ac2:	33 1f       	adc	r19, r19
     ac4:	e2 0f       	add	r30, r18
     ac6:	f3 1f       	adc	r31, r19
     ac8:	ef 5f       	subi	r30, 0xFF	; 255
     aca:	fc 4f       	sbci	r31, 0xFC	; 252
     acc:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     ace:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     ad0:	12 83       	std	Z+2, r17	; 0x02
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
				leds[zoid_always_black[i]] = CRGB::Black;
			}
			//set white pixels eyes
			for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     ad2:	e1 cf       	rjmp	.-62     	; 0xa96 <__stack+0x197>
     ad4:	40 e7       	ldi	r20, 0x70	; 112
     ad6:	a4 2e       	mov	r10, r20
     ad8:	42 e0       	ldi	r20, 0x02	; 2
     ada:	b4 2e       	mov	r11, r20
     adc:	d5 01       	movw	r26, r10
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
			}
		
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_r); i++){
     ade:	4a 16       	cp	r4, r26
     ae0:	5b 06       	cpc	r5, r27
     ae2:	71 f0       	breq	.+28     	; 0xb00 <__stack+0x201>
				leds[zoid_pupils_r[i]] = CRGB::DarkBlue;
     ae4:	ed 91       	ld	r30, X+
     ae6:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     ae8:	cf 01       	movw	r24, r30
     aea:	88 0f       	add	r24, r24
     aec:	99 1f       	adc	r25, r25
     aee:	e8 0f       	add	r30, r24
     af0:	f9 1f       	adc	r31, r25
     af2:	ef 5f       	subi	r30, 0xFF	; 255
     af4:	fc 4f       	sbci	r31, 0xFC	; 252
     af6:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     af8:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     afa:	2b e8       	ldi	r18, 0x8B	; 139
     afc:	22 83       	std	Z+2, r18	; 0x02
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
			}
		
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_r); i++){
     afe:	ef cf       	rjmp	.-34     	; 0xade <__stack+0x1df>
     b00:	a4 e6       	ldi	r26, 0x64	; 100
     b02:	b2 e0       	ldi	r27, 0x02	; 2
				leds[zoid_pupils_r[i]] = CRGB::DarkBlue;
			}
			//remove around feet (v1)
			for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     b04:	82 e0       	ldi	r24, 0x02	; 2
     b06:	a0 37       	cpi	r26, 0x70	; 112
     b08:	b8 07       	cpc	r27, r24
     b0a:	69 f0       	breq	.+26     	; 0xb26 <__stack+0x227>
				leds[zoid_void_pixels_1[i]] = CRGB::Black;
     b0c:	ed 91       	ld	r30, X+
     b0e:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     b10:	cf 01       	movw	r24, r30
     b12:	88 0f       	add	r24, r24
     b14:	99 1f       	adc	r25, r25
     b16:	e8 0f       	add	r30, r24
     b18:	f9 1f       	adc	r31, r25
     b1a:	ef 5f       	subi	r30, 0xFF	; 255
     b1c:	fc 4f       	sbci	r31, 0xFC	; 252
     b1e:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     b20:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     b22:	12 82       	std	Z+2, r1	; 0x02
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_r); i++){
				leds[zoid_pupils_r[i]] = CRGB::DarkBlue;
			}
			//remove around feet (v1)
			for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     b24:	ef cf       	rjmp	.-34     	; 0xb04 <__stack+0x205>
				leds[zoid_void_pixels_1[i]] = CRGB::Black;
			}
			FastLED.show();
     b26:	8a ed       	ldi	r24, 0xDA	; 218
     b28:	92 e0       	ldi	r25, 0x02	; 2
     b2a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		
			delay(feet_delay);
     b2e:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     b32:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     b36:	07 2e       	mov	r0, r23
     b38:	00 0c       	add	r0, r0
     b3a:	88 0b       	sbc	r24, r24
     b3c:	99 0b       	sbc	r25, r25
     b3e:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     b42:	09 83       	std	Y+1, r16	; 0x01
     b44:	1a 82       	std	Y+2, r1	; 0x02
     b46:	1b 82       	std	Y+3, r1	; 0x03

			//fill body
			fill_solid(leds, NUM_LEDS, CRGB::Red);
     b48:	ae 01       	movw	r20, r28
     b4a:	4f 5f       	subi	r20, 0xFF	; 255
     b4c:	5f 4f       	sbci	r21, 0xFF	; 255
     b4e:	64 ec       	ldi	r22, 0xC4	; 196
     b50:	70 e0       	ldi	r23, 0x00	; 0
     b52:	81 e0       	ldi	r24, 0x01	; 1
     b54:	93 e0       	ldi	r25, 0x03	; 3
     b56:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
		
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     b5a:	9a eb       	ldi	r25, 0xBA	; 186
     b5c:	69 16       	cp	r6, r25
     b5e:	92 e0       	ldi	r25, 0x02	; 2
     b60:	79 06       	cpc	r7, r25
     b62:	79 f0       	breq	.+30     	; 0xb82 <__stack+0x283>
				leds[zoid_always_black[i]] = CRGB::Black;
     b64:	d3 01       	movw	r26, r6
     b66:	ed 91       	ld	r30, X+
     b68:	3d 01       	movw	r6, r26
     b6a:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     b6c:	cf 01       	movw	r24, r30
     b6e:	88 0f       	add	r24, r24
     b70:	99 1f       	adc	r25, r25
     b72:	e8 0f       	add	r30, r24
     b74:	f9 1f       	adc	r31, r25
     b76:	ef 5f       	subi	r30, 0xFF	; 255
     b78:	fc 4f       	sbci	r31, 0xFC	; 252
     b7a:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     b7c:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     b7e:	12 82       	std	Z+2, r1	; 0x02

			//fill body
			fill_solid(leds, NUM_LEDS, CRGB::Red);
		
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
     b80:	ec cf       	rjmp	.-40     	; 0xb5a <__stack+0x25b>
				leds[zoid_always_black[i]] = CRGB::Black;
			}
			//set white pixels eyes
			for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     b82:	28 14       	cp	r2, r8
     b84:	39 04       	cpc	r3, r9
     b86:	f9 f0       	breq	.+62     	; 0xbc6 <__stack+0x2c7>
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
     b88:	d4 01       	movw	r26, r8
     b8a:	ed 91       	ld	r30, X+
     b8c:	4d 01       	movw	r8, r26
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     b90:	cf 01       	movw	r24, r30
     b92:	88 0f       	add	r24, r24
     b94:	99 1f       	adc	r25, r25
     b96:	e8 0f       	add	r30, r24
     b98:	f9 1f       	adc	r31, r25
     b9a:	ef 5f       	subi	r30, 0xFF	; 255
     b9c:	fc 4f       	sbci	r31, 0xFC	; 252
     b9e:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     ba0:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     ba2:	12 83       	std	Z+2, r17	; 0x02
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
     ba4:	ac 81       	ldd	r26, Y+4	; 0x04
     ba6:	bd 81       	ldd	r27, Y+5	; 0x05
     ba8:	ed 91       	ld	r30, X+
     baa:	bd 83       	std	Y+5, r27	; 0x05
     bac:	ac 83       	std	Y+4, r26	; 0x04
     bae:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     bb0:	cf 01       	movw	r24, r30
     bb2:	88 0f       	add	r24, r24
     bb4:	99 1f       	adc	r25, r25
     bb6:	e8 0f       	add	r30, r24
     bb8:	f9 1f       	adc	r31, r25
     bba:	ef 5f       	subi	r30, 0xFF	; 255
     bbc:	fc 4f       	sbci	r31, 0xFC	; 252
     bbe:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     bc0:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     bc2:	12 83       	std	Z+2, r17	; 0x02
			//set white pixels
			for (int i = 0; i < sizeof(zoid_always_black); i++){
				leds[zoid_always_black[i]] = CRGB::Black;
			}
			//set white pixels eyes
			for (int i = 0; i < sizeof(zoid_eyes_white_l); i++){
     bc4:	de cf       	rjmp	.-68     	; 0xb82 <__stack+0x283>
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
			}
		
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_r); i++){
     bc6:	4a 14       	cp	r4, r10
     bc8:	5b 04       	cpc	r5, r11
     bca:	81 f0       	breq	.+32     	; 0xbec <__stack+0x2ed>
				leds[zoid_pupils_r[i]] = CRGB::DarkBlue;
     bcc:	d5 01       	movw	r26, r10
     bce:	ed 91       	ld	r30, X+
     bd0:	5d 01       	movw	r10, r26
     bd2:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     bd4:	cf 01       	movw	r24, r30
     bd6:	88 0f       	add	r24, r24
     bd8:	99 1f       	adc	r25, r25
     bda:	e8 0f       	add	r30, r24
     bdc:	f9 1f       	adc	r31, r25
     bde:	ef 5f       	subi	r30, 0xFF	; 255
     be0:	fc 4f       	sbci	r31, 0xFC	; 252
     be2:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     be4:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     be6:	bb e8       	ldi	r27, 0x8B	; 139
     be8:	b2 83       	std	Z+2, r27	; 0x02
				leds[zoid_eyes_white_l[i]] = CRGB::White;	// left eye
				leds[zoid_eyes_white_r[i]] = CRGB::White;	// right eye
			}
		
			//set pupil
			for (int i = 0; i < sizeof(zoid_pupils_r); i++){
     bea:	ed cf       	rjmp	.-38     	; 0xbc6 <__stack+0x2c7>
     bec:	aa e5       	ldi	r26, 0x5A	; 90
     bee:	b2 e0       	ldi	r27, 0x02	; 2
				leds[zoid_pupils_r[i]] = CRGB::DarkBlue;
			}
		
			//remove around feet (v2)
			for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     bf0:	e2 e0       	ldi	r30, 0x02	; 2
     bf2:	a4 36       	cpi	r26, 0x64	; 100
     bf4:	be 07       	cpc	r27, r30
     bf6:	09 f4       	brne	.+2      	; 0xbfa <__stack+0x2fb>
     bf8:	0a cf       	rjmp	.-492    	; 0xa0e <__stack+0x10f>
				leds[zoid_void_pixels_2[i]] = CRGB::Black;
     bfa:	ed 91       	ld	r30, X+
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     bfe:	cf 01       	movw	r24, r30
     c00:	88 0f       	add	r24, r24
     c02:	99 1f       	adc	r25, r25
     c04:	e8 0f       	add	r30, r24
     c06:	f9 1f       	adc	r31, r25
     c08:	ef 5f       	subi	r30, 0xFF	; 255
     c0a:	fc 4f       	sbci	r31, 0xFC	; 252
     c0c:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     c0e:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     c10:	12 82       	std	Z+2, r1	; 0x02
			for (int i = 0; i < sizeof(zoid_pupils_r); i++){
				leds[zoid_pupils_r[i]] = CRGB::DarkBlue;
			}
		
			//remove around feet (v2)
			for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     c12:	ee cf       	rjmp	.-36     	; 0xbf0 <__stack+0x2f1>
void loop() {
	int i,j,k;
	
	FastLED.clear();
	
    for(int k = 0; k < reg_ghost_loop; k++){
     c14:	2f ef       	ldi	r18, 0xFF	; 255
     c16:	e2 1a       	sub	r14, r18
     c18:	f2 0a       	sbc	r15, r18
     c1a:	d0 cd       	rjmp	.-1120   	; 0x7bc <loop+0x50>
		//remove around feet (v2)
		for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
			leds[zoid_void_pixels_2[i]] = CRGB::Black;
		}
			
		FastLED.show();
     c1c:	8a ed       	ldi	r24, 0xDA	; 218
     c1e:	92 e0       	ldi	r25, 0x02	; 2
     c20:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
			
		delay(feet_delay);
     c24:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     c28:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     c2c:	07 2e       	mov	r0, r23
     c2e:	00 0c       	add	r0, r0
     c30:	88 0b       	sbc	r24, r24
     c32:	99 0b       	sbc	r25, r25
     c34:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
		}
    }
	
	
	// bad
	for(int k = 0; k < bad_ghost_loop; k++){
     c38:	0f 5f       	subi	r16, 0xFF	; 255
     c3a:	1f 4f       	sbci	r17, 0xFF	; 255
     c3c:	80 91 3e 02 	lds	r24, 0x023E	; 0x80023e <bad_ghost_loop>
     c40:	90 91 3f 02 	lds	r25, 0x023F	; 0x80023f <bad_ghost_loop+0x1>
     c44:	08 17       	cp	r16, r24
     c46:	19 07       	cpc	r17, r25
     c48:	4c f0       	brlt	.+18     	; 0xc5c <__stack+0x35d>
     c4a:	00 e0       	ldi	r16, 0x00	; 0
     c4c:	10 e0       	ldi	r17, 0x00	; 0
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     c4e:	4b e8       	ldi	r20, 0x8B	; 139
     c50:	b4 2e       	mov	r11, r20
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     c52:	ff 24       	eor	r15, r15
     c54:	fa 94       	dec	r15
     c56:	ee 24       	eor	r14, r14
     c58:	ea 94       	dec	r14
     c5a:	ae c0       	rjmp	.+348    	; 0xdb8 <__stack+0x4b9>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     c5c:	19 82       	std	Y+1, r1	; 0x01
     c5e:	1a 82       	std	Y+2, r1	; 0x02
     c60:	4b 82       	std	Y+3, r4	; 0x03

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::DarkBlue);
     c62:	ae 01       	movw	r20, r28
     c64:	4f 5f       	subi	r20, 0xFF	; 255
     c66:	5f 4f       	sbci	r21, 0xFF	; 255
     c68:	64 ec       	ldi	r22, 0xC4	; 196
     c6a:	70 e0       	ldi	r23, 0x00	; 0
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	93 e0       	ldi	r25, 0x03	; 3
     c70:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
     c74:	30 ea       	ldi	r19, 0xA0	; 160
     c76:	c3 2e       	mov	r12, r19
     c78:	32 e0       	ldi	r19, 0x02	; 2
     c7a:	d3 2e       	mov	r13, r19
     c7c:	d6 01       	movw	r26, r12
			
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     c7e:	6a 16       	cp	r6, r26
     c80:	7b 06       	cpc	r7, r27
     c82:	69 f0       	breq	.+26     	; 0xc9e <__stack+0x39f>
			leds[zoid_always_black[i]] = CRGB::Black;
     c84:	ed 91       	ld	r30, X+
     c86:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     c88:	cf 01       	movw	r24, r30
     c8a:	88 0f       	add	r24, r24
     c8c:	99 1f       	adc	r25, r25
     c8e:	e8 0f       	add	r30, r24
     c90:	f9 1f       	adc	r31, r25
     c92:	ef 5f       	subi	r30, 0xFF	; 255
     c94:	fc 4f       	sbci	r31, 0xFC	; 252
     c96:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     c98:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     c9a:	12 82       	std	Z+2, r1	; 0x02

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::DarkBlue);
			
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     c9c:	f0 cf       	rjmp	.-32     	; 0xc7e <__stack+0x37f>
     c9e:	76 e4       	ldi	r23, 0x46	; 70
     ca0:	e7 2e       	mov	r14, r23
     ca2:	72 e0       	ldi	r23, 0x02	; 2
     ca4:	f7 2e       	mov	r15, r23
     ca6:	d7 01       	movw	r26, r14
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     ca8:	aa 16       	cp	r10, r26
     caa:	bb 06       	cpc	r11, r27
     cac:	69 f0       	breq	.+26     	; 0xcc8 <__stack+0x3c9>
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	// 
     cae:	ed 91       	ld	r30, X+
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     cb2:	cf 01       	movw	r24, r30
     cb4:	88 0f       	add	r24, r24
     cb6:	99 1f       	adc	r25, r25
     cb8:	e8 0f       	add	r30, r24
     cba:	f9 1f       	adc	r31, r25
     cbc:	ef 5f       	subi	r30, 0xFF	; 255
     cbe:	fc 4f       	sbci	r31, 0xFC	; 252
     cc0:	50 82       	st	Z, r5
        g = (colorcode >>  8) & 0xFF;
     cc2:	51 82       	std	Z+1, r5	; 0x01
        b = (colorcode >>  0) & 0xFF;
     cc4:	12 82       	std	Z+2, r1	; 0x02
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     cc6:	f0 cf       	rjmp	.-32     	; 0xca8 <__stack+0x3a9>
     cc8:	a4 e6       	ldi	r26, 0x64	; 100
     cca:	b2 e0       	ldi	r27, 0x02	; 2
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	// 
		}

		//remove around feet (v1)
		for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     ccc:	8a 16       	cp	r8, r26
     cce:	9b 06       	cpc	r9, r27
     cd0:	69 f0       	breq	.+26     	; 0xcec <__stack+0x3ed>
			leds[zoid_void_pixels_1[i]] = CRGB::Black;
     cd2:	ed 91       	ld	r30, X+
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     cd6:	cf 01       	movw	r24, r30
     cd8:	88 0f       	add	r24, r24
     cda:	99 1f       	adc	r25, r25
     cdc:	e8 0f       	add	r30, r24
     cde:	f9 1f       	adc	r31, r25
     ce0:	ef 5f       	subi	r30, 0xFF	; 255
     ce2:	fc 4f       	sbci	r31, 0xFC	; 252
     ce4:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     ce6:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     ce8:	12 82       	std	Z+2, r1	; 0x02
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	// 
		}

		//remove around feet (v1)
		for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     cea:	f0 cf       	rjmp	.-32     	; 0xccc <__stack+0x3cd>
			leds[zoid_void_pixels_1[i]] = CRGB::Black;
		}
		FastLED.show();
     cec:	8a ed       	ldi	r24, 0xDA	; 218
     cee:	92 e0       	ldi	r25, 0x02	; 2
     cf0:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
			
		delay(feet_delay);
     cf4:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     cf8:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     cfc:	07 2e       	mov	r0, r23
     cfe:	00 0c       	add	r0, r0
     d00:	88 0b       	sbc	r24, r24
     d02:	99 0b       	sbc	r25, r25
     d04:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     d08:	19 82       	std	Y+1, r1	; 0x01
     d0a:	1a 82       	std	Y+2, r1	; 0x02
     d0c:	4b 82       	std	Y+3, r4	; 0x03

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::DarkBlue);
     d0e:	ae 01       	movw	r20, r28
     d10:	4f 5f       	subi	r20, 0xFF	; 255
     d12:	5f 4f       	sbci	r21, 0xFF	; 255
     d14:	64 ec       	ldi	r22, 0xC4	; 196
     d16:	70 e0       	ldi	r23, 0x00	; 0
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	93 e0       	ldi	r25, 0x03	; 3
     d1c:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
		
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     d20:	8a eb       	ldi	r24, 0xBA	; 186
     d22:	c8 16       	cp	r12, r24
     d24:	82 e0       	ldi	r24, 0x02	; 2
     d26:	d8 06       	cpc	r13, r24
     d28:	79 f0       	breq	.+30     	; 0xd48 <__stack+0x449>
			leds[zoid_always_black[i]] = CRGB::Black;
     d2a:	d6 01       	movw	r26, r12
     d2c:	ed 91       	ld	r30, X+
     d2e:	6d 01       	movw	r12, r26
     d30:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     d32:	cf 01       	movw	r24, r30
     d34:	88 0f       	add	r24, r24
     d36:	99 1f       	adc	r25, r25
     d38:	e8 0f       	add	r30, r24
     d3a:	f9 1f       	adc	r31, r25
     d3c:	ef 5f       	subi	r30, 0xFF	; 255
     d3e:	fc 4f       	sbci	r31, 0xFC	; 252
     d40:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     d42:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     d44:	12 82       	std	Z+2, r1	; 0x02

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::DarkBlue);
		
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     d46:	ec cf       	rjmp	.-40     	; 0xd20 <__stack+0x421>
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     d48:	ba e5       	ldi	r27, 0x5A	; 90
     d4a:	eb 16       	cp	r14, r27
     d4c:	b2 e0       	ldi	r27, 0x02	; 2
     d4e:	fb 06       	cpc	r15, r27
     d50:	79 f0       	breq	.+30     	; 0xd70 <__stack+0x471>
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	//
     d52:	d7 01       	movw	r26, r14
     d54:	ed 91       	ld	r30, X+
     d56:	7d 01       	movw	r14, r26
     d58:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     d5a:	cf 01       	movw	r24, r30
     d5c:	88 0f       	add	r24, r24
     d5e:	99 1f       	adc	r25, r25
     d60:	e8 0f       	add	r30, r24
     d62:	f9 1f       	adc	r31, r25
     d64:	ef 5f       	subi	r30, 0xFF	; 255
     d66:	fc 4f       	sbci	r31, 0xFC	; 252
     d68:	50 82       	st	Z, r5
        g = (colorcode >>  8) & 0xFF;
     d6a:	51 82       	std	Z+1, r5	; 0x01
        b = (colorcode >>  0) & 0xFF;
     d6c:	12 82       	std	Z+2, r1	; 0x02
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     d6e:	ec cf       	rjmp	.-40     	; 0xd48 <__stack+0x449>
     d70:	aa e5       	ldi	r26, 0x5A	; 90
     d72:	b2 e0       	ldi	r27, 0x02	; 2
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	//
		}
		
		//remove around feet (v2)
		for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     d74:	e2 e0       	ldi	r30, 0x02	; 2
     d76:	a4 36       	cpi	r26, 0x64	; 100
     d78:	be 07       	cpc	r27, r30
     d7a:	09 f4       	brne	.+2      	; 0xd7e <__stack+0x47f>
     d7c:	4f cf       	rjmp	.-354    	; 0xc1c <__stack+0x31d>
			leds[zoid_void_pixels_2[i]] = CRGB::Black;
     d7e:	ed 91       	ld	r30, X+
     d80:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     d82:	cf 01       	movw	r24, r30
     d84:	88 0f       	add	r24, r24
     d86:	99 1f       	adc	r25, r25
     d88:	e8 0f       	add	r30, r24
     d8a:	f9 1f       	adc	r31, r25
     d8c:	ef 5f       	subi	r30, 0xFF	; 255
     d8e:	fc 4f       	sbci	r31, 0xFC	; 252
     d90:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     d92:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     d94:	12 82       	std	Z+2, r1	; 0x02
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	//
		}
		
		//remove around feet (v2)
		for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     d96:	ee cf       	rjmp	.-36     	; 0xd74 <__stack+0x475>
		//remove around feet (v2)
		for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
			leds[zoid_void_pixels_2[i]] = CRGB::Black;
		}
		
		FastLED.show();
     d98:	8a ed       	ldi	r24, 0xDA	; 218
     d9a:	92 e0       	ldi	r25, 0x02	; 2
     d9c:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		
		delay(feet_delay);
     da0:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     da4:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     da8:	07 2e       	mov	r0, r23
     daa:	00 0c       	add	r0, r0
     dac:	88 0b       	sbc	r24, r24
     dae:	99 0b       	sbc	r25, r25
     db0:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
		delay(feet_delay);

	}
	
	// bad blink
	for(int k = 0; k < bad_ghost_blink_loop; k++){
     db4:	0f 5f       	subi	r16, 0xFF	; 255
     db6:	1f 4f       	sbci	r17, 0xFF	; 255
     db8:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <bad_ghost_blink_loop>
     dbc:	90 91 3d 02 	lds	r25, 0x023D	; 0x80023d <bad_ghost_blink_loop+0x1>
     dc0:	08 17       	cp	r16, r24
     dc2:	19 07       	cpc	r17, r25
     dc4:	44 f0       	brlt	.+16     	; 0xdd6 <__stack+0x4d7>
     dc6:	e1 2c       	mov	r14, r1
     dc8:	f1 2c       	mov	r15, r1
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     dca:	1f ef       	ldi	r17, 0xFF	; 255
     dcc:	78 e0       	ldi	r23, 0x08	; 8
     dce:	c7 2e       	mov	r12, r23
     dd0:	71 e0       	ldi	r23, 0x01	; 1
     dd2:	d7 2e       	mov	r13, r23
     dd4:	27 c1       	rjmp	.+590    	; 0x1024 <__stack+0x725>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     dd6:	19 82       	std	Y+1, r1	; 0x01
     dd8:	1a 82       	std	Y+2, r1	; 0x02
     dda:	bb 82       	std	Y+3, r11	; 0x03

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::DarkBlue);
     ddc:	ae 01       	movw	r20, r28
     dde:	4f 5f       	subi	r20, 0xFF	; 255
     de0:	5f 4f       	sbci	r21, 0xFF	; 255
     de2:	64 ec       	ldi	r22, 0xC4	; 196
     de4:	70 e0       	ldi	r23, 0x00	; 0
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	93 e0       	ldi	r25, 0x03	; 3
     dea:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
     dee:	60 ea       	ldi	r22, 0xA0	; 160
     df0:	86 2e       	mov	r8, r22
     df2:	62 e0       	ldi	r22, 0x02	; 2
     df4:	96 2e       	mov	r9, r22
     df6:	d4 01       	movw	r26, r8
		
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     df8:	f2 e0       	ldi	r31, 0x02	; 2
     dfa:	aa 3b       	cpi	r26, 0xBA	; 186
     dfc:	bf 07       	cpc	r27, r31
     dfe:	69 f0       	breq	.+26     	; 0xe1a <__stack+0x51b>
			leds[zoid_always_black[i]] = CRGB::Black;
     e00:	ed 91       	ld	r30, X+
     e02:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     e04:	cf 01       	movw	r24, r30
     e06:	88 0f       	add	r24, r24
     e08:	99 1f       	adc	r25, r25
     e0a:	e8 0f       	add	r30, r24
     e0c:	f9 1f       	adc	r31, r25
     e0e:	ef 5f       	subi	r30, 0xFF	; 255
     e10:	fc 4f       	sbci	r31, 0xFC	; 252
     e12:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     e14:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     e16:	12 82       	std	Z+2, r1	; 0x02

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::DarkBlue);
		
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     e18:	ef cf       	rjmp	.-34     	; 0xdf8 <__stack+0x4f9>
     e1a:	46 e4       	ldi	r20, 0x46	; 70
     e1c:	c4 2e       	mov	r12, r20
     e1e:	42 e0       	ldi	r20, 0x02	; 2
     e20:	d4 2e       	mov	r13, r20
     e22:	d6 01       	movw	r26, r12
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     e24:	22 e0       	ldi	r18, 0x02	; 2
     e26:	aa 35       	cpi	r26, 0x5A	; 90
     e28:	b2 07       	cpc	r27, r18
     e2a:	69 f0       	breq	.+26     	; 0xe46 <__stack+0x547>
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	//
     e2c:	ed 91       	ld	r30, X+
     e2e:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     e30:	cf 01       	movw	r24, r30
     e32:	88 0f       	add	r24, r24
     e34:	99 1f       	adc	r25, r25
     e36:	e8 0f       	add	r30, r24
     e38:	f9 1f       	adc	r31, r25
     e3a:	ef 5f       	subi	r30, 0xFF	; 255
     e3c:	fc 4f       	sbci	r31, 0xFC	; 252
     e3e:	f0 82       	st	Z, r15
        g = (colorcode >>  8) & 0xFF;
     e40:	f1 82       	std	Z+1, r15	; 0x01
        b = (colorcode >>  0) & 0xFF;
     e42:	12 82       	std	Z+2, r1	; 0x02
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     e44:	ef cf       	rjmp	.-34     	; 0xe24 <__stack+0x525>
     e46:	a4 e6       	ldi	r26, 0x64	; 100
     e48:	b2 e0       	ldi	r27, 0x02	; 2
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	//
		}

		//remove around feet (v1)
		for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     e4a:	82 e0       	ldi	r24, 0x02	; 2
     e4c:	a0 37       	cpi	r26, 0x70	; 112
     e4e:	b8 07       	cpc	r27, r24
     e50:	69 f0       	breq	.+26     	; 0xe6c <__stack+0x56d>
			leds[zoid_void_pixels_1[i]] = CRGB::Black;
     e52:	ed 91       	ld	r30, X+
     e54:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     e56:	cf 01       	movw	r24, r30
     e58:	88 0f       	add	r24, r24
     e5a:	99 1f       	adc	r25, r25
     e5c:	e8 0f       	add	r30, r24
     e5e:	f9 1f       	adc	r31, r25
     e60:	ef 5f       	subi	r30, 0xFF	; 255
     e62:	fc 4f       	sbci	r31, 0xFC	; 252
     e64:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     e66:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     e68:	12 82       	std	Z+2, r1	; 0x02
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
			leds[bad_eyes_mouth[i]] = CRGB::Yellow;	//
		}

		//remove around feet (v1)
		for (int i = 0; i < sizeof(zoid_void_pixels_1); i++){
     e6a:	ef cf       	rjmp	.-34     	; 0xe4a <__stack+0x54b>
			leds[zoid_void_pixels_1[i]] = CRGB::Black;
		}
		FastLED.show();
     e6c:	8a ed       	ldi	r24, 0xDA	; 218
     e6e:	92 e0       	ldi	r25, 0x02	; 2
     e70:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		
		delay(feet_delay);
     e74:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <feet_delay>
     e78:	70 91 45 02 	lds	r23, 0x0245	; 0x800245 <feet_delay+0x1>
     e7c:	07 2e       	mov	r0, r23
     e7e:	00 0c       	add	r0, r0
     e80:	88 0b       	sbc	r24, r24
     e82:	99 0b       	sbc	r25, r25
     e84:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
    {
    }

    /// allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
     e88:	e9 82       	std	Y+1, r14	; 0x01
     e8a:	ea 82       	std	Y+2, r14	; 0x02
     e8c:	1b 82       	std	Y+3, r1	; 0x03

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::Yellow);
     e8e:	ae 01       	movw	r20, r28
     e90:	4f 5f       	subi	r20, 0xFF	; 255
     e92:	5f 4f       	sbci	r21, 0xFF	; 255
     e94:	64 ec       	ldi	r22, 0xC4	; 196
     e96:	70 e0       	ldi	r23, 0x00	; 0
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	93 e0       	ldi	r25, 0x03	; 3
     e9c:	0e 94 5f 00 	call	0xbe	; 0xbe <_Z10fill_solidP4CRGBiRKS_>
		
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     ea0:	9a eb       	ldi	r25, 0xBA	; 186
     ea2:	89 16       	cp	r8, r25
     ea4:	92 e0       	ldi	r25, 0x02	; 2
     ea6:	99 06       	cpc	r9, r25
     ea8:	79 f0       	breq	.+30     	; 0xec8 <__stack+0x5c9>
			leds[zoid_always_black[i]] = CRGB::Black;
     eaa:	d4 01       	movw	r26, r8
     eac:	ed 91       	ld	r30, X+
     eae:	4d 01       	movw	r8, r26
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     eb2:	cf 01       	movw	r24, r30
     eb4:	88 0f       	add	r24, r24
     eb6:	99 1f       	adc	r25, r25
     eb8:	e8 0f       	add	r30, r24
     eba:	f9 1f       	adc	r31, r25
     ebc:	ef 5f       	subi	r30, 0xFF	; 255
     ebe:	fc 4f       	sbci	r31, 0xFC	; 252
     ec0:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     ec2:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     ec4:	12 82       	std	Z+2, r1	; 0x02

		//fill body
		fill_solid(leds, NUM_LEDS, CRGB::Yellow);
		
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
     ec6:	ec cf       	rjmp	.-40     	; 0xea0 <__stack+0x5a1>
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     ec8:	ba e5       	ldi	r27, 0x5A	; 90
     eca:	cb 16       	cp	r12, r27
     ecc:	b2 e0       	ldi	r27, 0x02	; 2
     ece:	db 06       	cpc	r13, r27
     ed0:	79 f0       	breq	.+30     	; 0xef0 <__stack+0x5f1>
			leds[bad_eyes_mouth[i]] = CRGB::Red;	//
     ed2:	d6 01       	movw	r26, r12
     ed4:	ed 91       	ld	r30, X+
     ed6:	6d 01       	movw	r12, r26
     ed8:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     eda:	cf 01       	movw	r24, r30
     edc:	88 0f       	add	r24, r24
     ede:	99 1f       	adc	r25, r25
     ee0:	e8 0f       	add	r30, r24
     ee2:	f9 1f       	adc	r31, r25
     ee4:	ef 5f       	subi	r30, 0xFF	; 255
     ee6:	fc 4f       	sbci	r31, 0xFC	; 252
     ee8:	f0 82       	st	Z, r15
        g = (colorcode >>  8) & 0xFF;
     eea:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     eec:	12 82       	std	Z+2, r1	; 0x02
		//set white pixels
		for (int i = 0; i < sizeof(zoid_always_black); i++){
			leds[zoid_always_black[i]] = CRGB::Black;
		}
		//set eyes and mouth
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
     eee:	ec cf       	rjmp	.-40     	; 0xec8 <__stack+0x5c9>
     ef0:	aa e5       	ldi	r26, 0x5A	; 90
     ef2:	b2 e0       	ldi	r27, 0x02	; 2
			leds[bad_eyes_mouth[i]] = CRGB::Red;	//
		}
		
		//remove around feet (v2)
		for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     ef4:	e2 e0       	ldi	r30, 0x02	; 2
     ef6:	a4 36       	cpi	r26, 0x64	; 100
     ef8:	be 07       	cpc	r27, r30
     efa:	09 f4       	brne	.+2      	; 0xefe <__stack+0x5ff>
     efc:	4d cf       	rjmp	.-358    	; 0xd98 <__stack+0x499>
			leds[zoid_void_pixels_2[i]] = CRGB::Black;
     efe:	ed 91       	ld	r30, X+
     f00:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     f02:	cf 01       	movw	r24, r30
     f04:	88 0f       	add	r24, r24
     f06:	99 1f       	adc	r25, r25
     f08:	e8 0f       	add	r30, r24
     f0a:	f9 1f       	adc	r31, r25
     f0c:	ef 5f       	subi	r30, 0xFF	; 255
     f0e:	fc 4f       	sbci	r31, 0xFC	; 252
     f10:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
     f12:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     f14:	12 82       	std	Z+2, r1	; 0x02
		for (int i = 0; i < sizeof(bad_eyes_mouth); i++){
			leds[bad_eyes_mouth[i]] = CRGB::Red;	//
		}
		
		//remove around feet (v2)
		for (int i = 0; i < sizeof(zoid_void_pixels_2); i++){
     f16:	ee cf       	rjmp	.-36     	; 0xef4 <__stack+0x5f5>
     f18:	a0 e3       	ldi	r26, 0x30	; 48
     f1a:	b1 e0       	ldi	r27, 0x01	; 1
	
	
		for (i  = 0; i < sizeof(pacg_ph3_body); i ++) {
			leds[pacg_ph3_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph3_lips); i ++) {
     f1c:	e1 e0       	ldi	r30, 0x01	; 1
     f1e:	a4 33       	cpi	r26, 0x34	; 52
     f20:	be 07       	cpc	r27, r30
     f22:	09 f0       	breq	.+2      	; 0xf26 <__stack+0x627>
     f24:	66 c1       	rjmp	.+716    	; 0x11f2 <__stack+0x8f3>
			leds[pacg_ph3_lips[i]] = CRGB::Red;
		}
		for (i  = 0; i < sizeof(pacg_ph3_mouth); i ++) {
			leds[pacg_ph3_mouth[i]] = CRGB::Magenta;
     f26:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <pacg_ph3_mouth>
     f2a:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     f2c:	cf 01       	movw	r24, r30
     f2e:	88 0f       	add	r24, r24
     f30:	99 1f       	adc	r25, r25
     f32:	e8 0f       	add	r30, r24
     f34:	f9 1f       	adc	r31, r25
     f36:	ef 5f       	subi	r30, 0xFF	; 255
     f38:	fc 4f       	sbci	r31, 0xFC	; 252
     f3a:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     f3c:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     f3e:	12 83       	std	Z+2, r17	; 0x02
     f40:	e0 91 2f 01 	lds	r30, 0x012F	; 0x80012f <pacg_ph3_mouth+0x1>
     f44:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     f46:	cf 01       	movw	r24, r30
     f48:	88 0f       	add	r24, r24
     f4a:	99 1f       	adc	r25, r25
     f4c:	e8 0f       	add	r30, r24
     f4e:	f9 1f       	adc	r31, r25
     f50:	ef 5f       	subi	r30, 0xFF	; 255
     f52:	fc 4f       	sbci	r31, 0xFC	; 252
     f54:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     f56:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     f58:	12 83       	std	Z+2, r17	; 0x02
		}
		FastLED.show();
     f5a:	8a ed       	ldi	r24, 0xDA	; 218
     f5c:	92 e0       	ldi	r25, 0x02	; 2
     f5e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		delay(200);
     f62:	68 ec       	ldi	r22, 0xC8	; 200
     f64:	70 e0       	ldi	r23, 0x00	; 0
     f66:	80 e0       	ldi	r24, 0x00	; 0
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
     f6e:	ab e0       	ldi	r26, 0x0B	; 11
     f70:	b1 e0       	ldi	r27, 0x01	; 1
	
		
		for (i  = 0; i < sizeof(pacg_ph4_black); i ++) {
     f72:	f1 e0       	ldi	r31, 0x01	; 1
     f74:	ae 32       	cpi	r26, 0x2E	; 46
     f76:	bf 07       	cpc	r27, r31
     f78:	09 f0       	breq	.+2      	; 0xf7c <__stack+0x67d>
     f7a:	48 c1       	rjmp	.+656    	; 0x120c <__stack+0x90d>
			leds[pacg_ph4_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph4_body); i ++) {
			leds[pacg_ph4_body[i]] = CRGB::Yellow;
     f7c:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pacg_ph4_body>
     f80:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     f82:	cf 01       	movw	r24, r30
     f84:	88 0f       	add	r24, r24
     f86:	99 1f       	adc	r25, r25
     f88:	e8 0f       	add	r30, r24
     f8a:	f9 1f       	adc	r31, r25
     f8c:	ef 5f       	subi	r30, 0xFF	; 255
     f8e:	fc 4f       	sbci	r31, 0xFC	; 252
     f90:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     f92:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     f94:	12 82       	std	Z+2, r1	; 0x02
     f96:	e0 91 03 01 	lds	r30, 0x0103	; 0x800103 <pacg_ph4_body+0x1>
     f9a:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     f9c:	cf 01       	movw	r24, r30
     f9e:	88 0f       	add	r24, r24
     fa0:	99 1f       	adc	r25, r25
     fa2:	e8 0f       	add	r30, r24
     fa4:	f9 1f       	adc	r31, r25
     fa6:	ef 5f       	subi	r30, 0xFF	; 255
     fa8:	fc 4f       	sbci	r31, 0xFC	; 252
     faa:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     fac:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
     fae:	12 82       	std	Z+2, r1	; 0x02
     fb0:	a4 e0       	ldi	r26, 0x04	; 4
     fb2:	b1 e0       	ldi	r27, 0x01	; 1
		}
		for (i  = 0; i < sizeof(pacg_ph4_lips); i ++) {
     fb4:	ca 16       	cp	r12, r26
     fb6:	db 06       	cpc	r13, r27
     fb8:	09 f0       	breq	.+2      	; 0xfbc <__stack+0x6bd>
     fba:	35 c1       	rjmp	.+618    	; 0x1226 <__stack+0x927>
			leds[pacg_ph4_lips[i]] = CRGB::Red;
		}
		for (i  = 0; i < sizeof(pacg_ph4_mouth); i ++) {
			leds[pacg_ph4_mouth[i]] = CRGB::Magenta;
     fbc:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <pacg_ph4_mouth>
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     fc2:	cf 01       	movw	r24, r30
     fc4:	88 0f       	add	r24, r24
     fc6:	99 1f       	adc	r25, r25
     fc8:	e8 0f       	add	r30, r24
     fca:	f9 1f       	adc	r31, r25
     fcc:	ef 5f       	subi	r30, 0xFF	; 255
     fce:	fc 4f       	sbci	r31, 0xFC	; 252
     fd0:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     fd2:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     fd4:	12 83       	std	Z+2, r17	; 0x02
     fd6:	e0 91 09 01 	lds	r30, 0x0109	; 0x800109 <pacg_ph4_mouth+0x1>
     fda:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     fdc:	cf 01       	movw	r24, r30
     fde:	88 0f       	add	r24, r24
     fe0:	99 1f       	adc	r25, r25
     fe2:	e8 0f       	add	r30, r24
     fe4:	f9 1f       	adc	r31, r25
     fe6:	ef 5f       	subi	r30, 0xFF	; 255
     fe8:	fc 4f       	sbci	r31, 0xFC	; 252
     fea:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
     fec:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
     fee:	12 83       	std	Z+2, r17	; 0x02
		}
		for (i  = 0; i < sizeof(pacg_ph4_eyes); i ++) {
			leds[pacg_ph4_eyes[i]] = CRGB::Blue;
     ff0:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <pacg_ph4_eyes>
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
     ff6:	cf 01       	movw	r24, r30
     ff8:	88 0f       	add	r24, r24
     ffa:	99 1f       	adc	r25, r25
     ffc:	e8 0f       	add	r30, r24
     ffe:	f9 1f       	adc	r31, r25
    1000:	ef 5f       	subi	r30, 0xFF	; 255
    1002:	fc 4f       	sbci	r31, 0xFC	; 252
    1004:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    1006:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    1008:	12 83       	std	Z+2, r17	; 0x02
		}
		FastLED.show();
    100a:	8a ed       	ldi	r24, 0xDA	; 218
    100c:	92 e0       	ldi	r25, 0x02	; 2
    100e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		delay(200);
    1012:	68 ec       	ldi	r22, 0xC8	; 200
    1014:	70 e0       	ldi	r23, 0x00	; 0
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
	}


	
	// pac girl
	for (k = 0; k < pac_girl_loop; k++){
    101e:	2f ef       	ldi	r18, 0xFF	; 255
    1020:	e2 1a       	sub	r14, r18
    1022:	f2 0a       	sbc	r15, r18
    1024:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    1028:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
    102c:	e8 16       	cp	r14, r24
    102e:	f9 06       	cpc	r15, r25
    1030:	0c f0       	brlt	.+2      	; 0x1034 <__stack+0x735>
    1032:	06 c1       	rjmp	.+524    	; 0x1240 <__stack+0x941>
		FastLED.clear();
    1034:	60 e0       	ldi	r22, 0x00	; 0
    1036:	8a ed       	ldi	r24, 0xDA	; 218
    1038:	92 e0       	ldi	r25, 0x02	; 2
    103a:	0e 94 7f 02 	call	0x4fe	; 0x4fe <_ZN8CFastLED5clearEb>
    103e:	ac e0       	ldi	r26, 0x0C	; 12
    1040:	b2 e0       	ldi	r27, 0x02	; 2
		
		for (i  = 0; i < sizeof(pacg_always_black); i ++) {
    1042:	f2 e0       	ldi	r31, 0x02	; 2
    1044:	ac 33       	cpi	r26, 0x3C	; 60
    1046:	bf 07       	cpc	r27, r31
    1048:	69 f0       	breq	.+26     	; 0x1064 <__stack+0x765>
			leds[pacg_always_black[i]] = CRGB::Black;
    104a:	ed 91       	ld	r30, X+
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    104e:	cf 01       	movw	r24, r30
    1050:	88 0f       	add	r24, r24
    1052:	99 1f       	adc	r25, r25
    1054:	e8 0f       	add	r30, r24
    1056:	f9 1f       	adc	r31, r25
    1058:	ef 5f       	subi	r30, 0xFF	; 255
    105a:	fc 4f       	sbci	r31, 0xFC	; 252
    105c:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    105e:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    1060:	12 82       	std	Z+2, r1	; 0x02
	
	// pac girl
	for (k = 0; k < pac_girl_loop; k++){
		FastLED.clear();
		
		for (i  = 0; i < sizeof(pacg_always_black); i ++) {
    1062:	ef cf       	rjmp	.-34     	; 0x1042 <__stack+0x743>
    1064:	af ec       	ldi	r26, 0xCF	; 207
    1066:	b1 e0       	ldi	r27, 0x01	; 1
			leds[pacg_always_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph1_black); i ++) {
    1068:	22 e0       	ldi	r18, 0x02	; 2
    106a:	ac 30       	cpi	r26, 0x0C	; 12
    106c:	b2 07       	cpc	r27, r18
    106e:	69 f0       	breq	.+26     	; 0x108a <__stack+0x78b>
			leds[pacg_ph1_black[i]] = CRGB::Black;
    1070:	ed 91       	ld	r30, X+
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    1074:	cf 01       	movw	r24, r30
    1076:	88 0f       	add	r24, r24
    1078:	99 1f       	adc	r25, r25
    107a:	e8 0f       	add	r30, r24
    107c:	f9 1f       	adc	r31, r25
    107e:	ef 5f       	subi	r30, 0xFF	; 255
    1080:	fc 4f       	sbci	r31, 0xFC	; 252
    1082:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    1084:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    1086:	12 82       	std	Z+2, r1	; 0x02
		FastLED.clear();
		
		for (i  = 0; i < sizeof(pacg_always_black); i ++) {
			leds[pacg_always_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph1_black); i ++) {
    1088:	ef cf       	rjmp	.-34     	; 0x1068 <__stack+0x769>
    108a:	a4 e9       	ldi	r26, 0x94	; 148
    108c:	b1 e0       	ldi	r27, 0x01	; 1
			leds[pacg_ph1_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph1_body); i ++) {
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	af 3c       	cpi	r26, 0xCF	; 207
    1092:	b8 07       	cpc	r27, r24
    1094:	69 f0       	breq	.+26     	; 0x10b0 <__stack+0x7b1>
			leds[pacg_ph1_body[i]] = CRGB::Yellow;
    1096:	ed 91       	ld	r30, X+
    1098:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    109a:	cf 01       	movw	r24, r30
    109c:	88 0f       	add	r24, r24
    109e:	99 1f       	adc	r25, r25
    10a0:	e8 0f       	add	r30, r24
    10a2:	f9 1f       	adc	r31, r25
    10a4:	ef 5f       	subi	r30, 0xFF	; 255
    10a6:	fc 4f       	sbci	r31, 0xFC	; 252
    10a8:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    10aa:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
    10ac:	12 82       	std	Z+2, r1	; 0x02
			leds[pacg_always_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph1_black); i ++) {
			leds[pacg_ph1_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph1_body); i ++) {
    10ae:	ef cf       	rjmp	.-34     	; 0x108e <__stack+0x78f>
    10b0:	a0 e8       	ldi	r26, 0x80	; 128
    10b2:	b1 e0       	ldi	r27, 0x01	; 1
			leds[pacg_ph1_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph1_lips); i ++) {
    10b4:	91 e0       	ldi	r25, 0x01	; 1
    10b6:	a4 39       	cpi	r26, 0x94	; 148
    10b8:	b9 07       	cpc	r27, r25
    10ba:	69 f0       	breq	.+26     	; 0x10d6 <__stack+0x7d7>
			leds[pacg_ph1_lips[i]] = CRGB::Red;
    10bc:	ed 91       	ld	r30, X+
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    10c0:	cf 01       	movw	r24, r30
    10c2:	88 0f       	add	r24, r24
    10c4:	99 1f       	adc	r25, r25
    10c6:	e8 0f       	add	r30, r24
    10c8:	f9 1f       	adc	r31, r25
    10ca:	ef 5f       	subi	r30, 0xFF	; 255
    10cc:	fc 4f       	sbci	r31, 0xFC	; 252
    10ce:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    10d0:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    10d2:	12 82       	std	Z+2, r1	; 0x02
			leds[pacg_ph1_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph1_body); i ++) {
			leds[pacg_ph1_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph1_lips); i ++) {
    10d4:	ef cf       	rjmp	.-34     	; 0x10b4 <__stack+0x7b5>
    10d6:	ab e7       	ldi	r26, 0x7B	; 123
    10d8:	b1 e0       	ldi	r27, 0x01	; 1
			leds[pacg_ph1_lips[i]] = CRGB::Red;
		}
		for (i  = 0; i < sizeof(pacg_ph1_mouth); i ++) {
    10da:	e1 e0       	ldi	r30, 0x01	; 1
    10dc:	a0 38       	cpi	r26, 0x80	; 128
    10de:	be 07       	cpc	r27, r30
    10e0:	69 f0       	breq	.+26     	; 0x10fc <__stack+0x7fd>
			leds[pacg_ph1_mouth[i]] = CRGB::Magenta;
    10e2:	ed 91       	ld	r30, X+
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    10e6:	cf 01       	movw	r24, r30
    10e8:	88 0f       	add	r24, r24
    10ea:	99 1f       	adc	r25, r25
    10ec:	e8 0f       	add	r30, r24
    10ee:	f9 1f       	adc	r31, r25
    10f0:	ef 5f       	subi	r30, 0xFF	; 255
    10f2:	fc 4f       	sbci	r31, 0xFC	; 252
    10f4:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    10f6:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    10f8:	12 83       	std	Z+2, r17	; 0x02
			leds[pacg_ph1_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph1_lips); i ++) {
			leds[pacg_ph1_lips[i]] = CRGB::Red;
		}
		for (i  = 0; i < sizeof(pacg_ph1_mouth); i ++) {
    10fa:	ef cf       	rjmp	.-34     	; 0x10da <__stack+0x7db>
    10fc:	a8 e7       	ldi	r26, 0x78	; 120
    10fe:	b1 e0       	ldi	r27, 0x01	; 1
			leds[pacg_ph1_mouth[i]] = CRGB::Magenta;
		}
		for (i  = 0; i < sizeof(pacg_ph1_eyes); i ++) {
    1100:	f1 e0       	ldi	r31, 0x01	; 1
    1102:	ab 37       	cpi	r26, 0x7B	; 123
    1104:	bf 07       	cpc	r27, r31
    1106:	69 f0       	breq	.+26     	; 0x1122 <__stack+0x823>
			leds[pacg_ph1_eyes[i]] = CRGB::Blue;
    1108:	ed 91       	ld	r30, X+
    110a:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    110c:	cf 01       	movw	r24, r30
    110e:	88 0f       	add	r24, r24
    1110:	99 1f       	adc	r25, r25
    1112:	e8 0f       	add	r30, r24
    1114:	f9 1f       	adc	r31, r25
    1116:	ef 5f       	subi	r30, 0xFF	; 255
    1118:	fc 4f       	sbci	r31, 0xFC	; 252
    111a:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    111c:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    111e:	12 83       	std	Z+2, r17	; 0x02
			leds[pacg_ph1_lips[i]] = CRGB::Red;
		}
		for (i  = 0; i < sizeof(pacg_ph1_mouth); i ++) {
			leds[pacg_ph1_mouth[i]] = CRGB::Magenta;
		}
		for (i  = 0; i < sizeof(pacg_ph1_eyes); i ++) {
    1120:	ef cf       	rjmp	.-34     	; 0x1100 <__stack+0x801>
			leds[pacg_ph1_eyes[i]] = CRGB::Blue;
		}		
		FastLED.show();
    1122:	8a ed       	ldi	r24, 0xDA	; 218
    1124:	92 e0       	ldi	r25, 0x02	; 2
    1126:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		delay(200);
    112a:	68 ec       	ldi	r22, 0xC8	; 200
    112c:	70 e0       	ldi	r23, 0x00	; 0
    112e:	80 e0       	ldi	r24, 0x00	; 0
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
		
		
		for (i  = 0; i < sizeof(pacg_ph2_black); i ++) {
			leds[pacg_ph2_black[i]] = CRGB::Black;
    1136:	e0 91 76 01 	lds	r30, 0x0176	; 0x800176 <pacg_ph2_black>
    113a:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    113c:	cf 01       	movw	r24, r30
    113e:	88 0f       	add	r24, r24
    1140:	99 1f       	adc	r25, r25
    1142:	e8 0f       	add	r30, r24
    1144:	f9 1f       	adc	r31, r25
    1146:	ef 5f       	subi	r30, 0xFF	; 255
    1148:	fc 4f       	sbci	r31, 0xFC	; 252
    114a:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    114c:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    114e:	12 82       	std	Z+2, r1	; 0x02
    1150:	e0 91 77 01 	lds	r30, 0x0177	; 0x800177 <pacg_ph2_black+0x1>
    1154:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    1156:	cf 01       	movw	r24, r30
    1158:	88 0f       	add	r24, r24
    115a:	99 1f       	adc	r25, r25
    115c:	e8 0f       	add	r30, r24
    115e:	f9 1f       	adc	r31, r25
    1160:	ef 5f       	subi	r30, 0xFF	; 255
    1162:	fc 4f       	sbci	r31, 0xFC	; 252
    1164:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    1166:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    1168:	12 82       	std	Z+2, r1	; 0x02
    116a:	ad e5       	ldi	r26, 0x5D	; 93
    116c:	b1 e0       	ldi	r27, 0x01	; 1
		}
		for (i  = 0; i < sizeof(pacg_ph2_body); i ++) {
    116e:	21 e0       	ldi	r18, 0x01	; 1
    1170:	a6 37       	cpi	r26, 0x76	; 118
    1172:	b2 07       	cpc	r27, r18
    1174:	69 f0       	breq	.+26     	; 0x1190 <__stack+0x891>
			leds[pacg_ph2_body[i]] = CRGB::Yellow;
    1176:	ed 91       	ld	r30, X+
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    117a:	cf 01       	movw	r24, r30
    117c:	88 0f       	add	r24, r24
    117e:	99 1f       	adc	r25, r25
    1180:	e8 0f       	add	r30, r24
    1182:	f9 1f       	adc	r31, r25
    1184:	ef 5f       	subi	r30, 0xFF	; 255
    1186:	fc 4f       	sbci	r31, 0xFC	; 252
    1188:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    118a:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
    118c:	12 82       	std	Z+2, r1	; 0x02
		
		
		for (i  = 0; i < sizeof(pacg_ph2_black); i ++) {
			leds[pacg_ph2_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph2_body); i ++) {
    118e:	ef cf       	rjmp	.-34     	; 0x116e <__stack+0x86f>
    1190:	a9 e5       	ldi	r26, 0x59	; 89
    1192:	b1 e0       	ldi	r27, 0x01	; 1
			leds[pacg_ph2_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph2_lips); i ++) {
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	ad 35       	cpi	r26, 0x5D	; 93
    1198:	b8 07       	cpc	r27, r24
    119a:	69 f0       	breq	.+26     	; 0x11b6 <__stack+0x8b7>
			leds[pacg_ph2_lips[i]] = CRGB::Red;
    119c:	ed 91       	ld	r30, X+
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    11a0:	cf 01       	movw	r24, r30
    11a2:	88 0f       	add	r24, r24
    11a4:	99 1f       	adc	r25, r25
    11a6:	e8 0f       	add	r30, r24
    11a8:	f9 1f       	adc	r31, r25
    11aa:	ef 5f       	subi	r30, 0xFF	; 255
    11ac:	fc 4f       	sbci	r31, 0xFC	; 252
    11ae:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    11b0:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    11b2:	12 82       	std	Z+2, r1	; 0x02
			leds[pacg_ph2_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph2_body); i ++) {
			leds[pacg_ph2_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph2_lips); i ++) {
    11b4:	ef cf       	rjmp	.-34     	; 0x1194 <__stack+0x895>
			leds[pacg_ph2_lips[i]] = CRGB::Red;
		}		
		FastLED.show();
    11b6:	8a ed       	ldi	r24, 0xDA	; 218
    11b8:	92 e0       	ldi	r25, 0x02	; 2
    11ba:	0e 94 51 03 	call	0x6a2	; 0x6a2 <_ZN8CFastLED4showEv>
		delay(200);
    11be:	68 ec       	ldi	r22, 0xC8	; 200
    11c0:	70 e0       	ldi	r23, 0x00	; 0
    11c2:	80 e0       	ldi	r24, 0x00	; 0
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <delay>
    11ca:	a4 e3       	ldi	r26, 0x34	; 52
    11cc:	b1 e0       	ldi	r27, 0x01	; 1
	
	
		for (i  = 0; i < sizeof(pacg_ph3_body); i ++) {
    11ce:	91 e0       	ldi	r25, 0x01	; 1
    11d0:	a9 35       	cpi	r26, 0x59	; 89
    11d2:	b9 07       	cpc	r27, r25
    11d4:	09 f4       	brne	.+2      	; 0x11d8 <__stack+0x8d9>
    11d6:	a0 ce       	rjmp	.-704    	; 0xf18 <__stack+0x619>
			leds[pacg_ph3_body[i]] = CRGB::Yellow;
    11d8:	ed 91       	ld	r30, X+
    11da:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    11dc:	cf 01       	movw	r24, r30
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
    11e2:	e8 0f       	add	r30, r24
    11e4:	f9 1f       	adc	r31, r25
    11e6:	ef 5f       	subi	r30, 0xFF	; 255
    11e8:	fc 4f       	sbci	r31, 0xFC	; 252
    11ea:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    11ec:	11 83       	std	Z+1, r17	; 0x01
        b = (colorcode >>  0) & 0xFF;
    11ee:	12 82       	std	Z+2, r1	; 0x02
		}		
		FastLED.show();
		delay(200);
	
	
		for (i  = 0; i < sizeof(pacg_ph3_body); i ++) {
    11f0:	ee cf       	rjmp	.-36     	; 0x11ce <__stack+0x8cf>
			leds[pacg_ph3_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph3_lips); i ++) {
			leds[pacg_ph3_lips[i]] = CRGB::Red;
    11f2:	ed 91       	ld	r30, X+
    11f4:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    11f6:	cf 01       	movw	r24, r30
    11f8:	88 0f       	add	r24, r24
    11fa:	99 1f       	adc	r25, r25
    11fc:	e8 0f       	add	r30, r24
    11fe:	f9 1f       	adc	r31, r25
    1200:	ef 5f       	subi	r30, 0xFF	; 255
    1202:	fc 4f       	sbci	r31, 0xFC	; 252
    1204:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    1206:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    1208:	12 82       	std	Z+2, r1	; 0x02
	
	
		for (i  = 0; i < sizeof(pacg_ph3_body); i ++) {
			leds[pacg_ph3_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph3_lips); i ++) {
    120a:	88 ce       	rjmp	.-752    	; 0xf1c <__stack+0x61d>
		FastLED.show();
		delay(200);
	
		
		for (i  = 0; i < sizeof(pacg_ph4_black); i ++) {
			leds[pacg_ph4_black[i]] = CRGB::Black;
    120c:	ed 91       	ld	r30, X+
    120e:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    1210:	cf 01       	movw	r24, r30
    1212:	88 0f       	add	r24, r24
    1214:	99 1f       	adc	r25, r25
    1216:	e8 0f       	add	r30, r24
    1218:	f9 1f       	adc	r31, r25
    121a:	ef 5f       	subi	r30, 0xFF	; 255
    121c:	fc 4f       	sbci	r31, 0xFC	; 252
    121e:	10 82       	st	Z, r1
        g = (colorcode >>  8) & 0xFF;
    1220:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    1222:	12 82       	std	Z+2, r1	; 0x02
		}
		FastLED.show();
		delay(200);
	
		
		for (i  = 0; i < sizeof(pacg_ph4_black); i ++) {
    1224:	a6 ce       	rjmp	.-692    	; 0xf72 <__stack+0x673>
		}
		for (i  = 0; i < sizeof(pacg_ph4_body); i ++) {
			leds[pacg_ph4_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph4_lips); i ++) {
			leds[pacg_ph4_lips[i]] = CRGB::Red;
    1226:	ed 91       	ld	r30, X+
    1228:	f0 e0       	ldi	r31, 0x00	; 0
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
    122a:	cf 01       	movw	r24, r30
    122c:	88 0f       	add	r24, r24
    122e:	99 1f       	adc	r25, r25
    1230:	e8 0f       	add	r30, r24
    1232:	f9 1f       	adc	r31, r25
    1234:	ef 5f       	subi	r30, 0xFF	; 255
    1236:	fc 4f       	sbci	r31, 0xFC	; 252
    1238:	10 83       	st	Z, r17
        g = (colorcode >>  8) & 0xFF;
    123a:	11 82       	std	Z+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
    123c:	12 82       	std	Z+2, r1	; 0x02
			leds[pacg_ph4_black[i]] = CRGB::Black;
		}
		for (i  = 0; i < sizeof(pacg_ph4_body); i ++) {
			leds[pacg_ph4_body[i]] = CRGB::Yellow;
		}
		for (i  = 0; i < sizeof(pacg_ph4_lips); i ++) {
    123e:	ba ce       	rjmp	.-652    	; 0xfb4 <__stack+0x6b5>
	}
	
	
	

}
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	0f 90       	pop	r0
    1248:	0f 90       	pop	r0
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	1f 91       	pop	r17
    1250:	0f 91       	pop	r16
    1252:	ff 90       	pop	r15
    1254:	ef 90       	pop	r14
    1256:	df 90       	pop	r13
    1258:	cf 90       	pop	r12
    125a:	bf 90       	pop	r11
    125c:	af 90       	pop	r10
    125e:	9f 90       	pop	r9
    1260:	8f 90       	pop	r8
    1262:	7f 90       	pop	r7
    1264:	6f 90       	pop	r6
    1266:	5f 90       	pop	r5
    1268:	4f 90       	pop	r4
    126a:	3f 90       	pop	r3
    126c:	2f 90       	pop	r2
    126e:	08 95       	ret

00001270 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE15showRGBInternalER15PixelControllerILS0_10ELi1ELm4294967295EE>:
#define DADVANCE 3
#define DUSE (0xFF - (DADVANCE-1))

	// This method is made static to force making register Y available to use for data on AVR - if the method is non-static, then
	// gcc will use register Y for the this pointer.
	static void /*__attribute__((optimize("O0")))*/  /*__attribute__ ((always_inline))*/  showRGBInternal(PixelController<RGB_ORDER> & pixels)  {
    1270:	9f 92       	push	r9
    1272:	af 92       	push	r10
    1274:	bf 92       	push	r11
    1276:	cf 92       	push	r12
    1278:	df 92       	push	r13
    127a:	ef 92       	push	r14
    127c:	ff 92       	push	r15
    127e:	0f 93       	push	r16
    1280:	1f 93       	push	r17
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
    1286:	fc 01       	movw	r30, r24
		uint8_t *data = (uint8_t*)pixels.mData;
    1288:	c0 80       	ld	r12, Z
    128a:	d1 80       	ldd	r13, Z+1	; 0x01
		data_ptr_t port = FastPin<DATA_PIN>::port();
		data_t mask = FastPin<DATA_PIN>::mask();
		uint8_t scale_base = 0;

		// register uint8_t *end = data + nLeds;
		data_t hi = *port | mask;
    128c:	2b b1       	in	r18, 0x0b	; 11
    128e:	28 60       	ori	r18, 0x08	; 8
    1290:	b2 2e       	mov	r11, r18
		data_t lo = *port & ~mask;
    1292:	9b b1       	in	r25, 0x0b	; 11
    1294:	97 7f       	andi	r25, 0xF7	; 247
		*port = lo;
    1296:	9b b9       	out	0x0b, r25	; 11
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
    1298:	61 85       	ldd	r22, Z+9	; 0x09
    129a:	86 81       	ldd	r24, Z+6	; 0x06
    129c:	06 2f       	mov	r16, r22
    129e:	08 1b       	sub	r16, r24
    12a0:	80 2f       	mov	r24, r16
    12a2:	06 83       	std	Z+6, r16	; 0x06

		// Setup the pixel controller
		pixels.preStepFirstByteDithering();

		// pull the dithering/adjustment values out of the pixels object for direct asm access
		uint8_t advanceBy = pixels.advanceBy();
    12a4:	77 85       	ldd	r23, Z+15	; 0x0f
		uint16_t count = pixels.mLen;
    12a6:	a2 81       	ldd	r26, Z+2	; 0x02
    12a8:	b3 81       	ldd	r27, Z+3	; 0x03

		uint8_t s0 = pixels.mScale.raw[RO(0)];
    12aa:	34 85       	ldd	r19, Z+12	; 0x0c
		uint8_t s1 = pixels.mScale.raw[RO(1)];
    12ac:	45 85       	ldd	r20, Z+13	; 0x0d
		uint8_t s2 = pixels.mScale.raw[RO(2)];
    12ae:	56 85       	ldd	r21, Z+14	; 0x0e
#if (FASTLED_SCALE8_FIXED==1)
		s0++; s1++; s2++;
    12b0:	99 24       	eor	r9, r9
    12b2:	93 94       	inc	r9
    12b4:	93 0e       	add	r9, r19
    12b6:	4f 5f       	subi	r20, 0xFF	; 255
    12b8:	5f 5f       	subi	r21, 0xFF	; 255
#endif
		uint8_t d0 = pixels.d[RO(0)];
		uint8_t d1 = pixels.d[RO(1)];
    12ba:	f7 80       	ldd	r15, Z+7	; 0x07
		uint8_t d2 = pixels.d[RO(2)];
    12bc:	e0 84       	ldd	r14, Z+8	; 0x08
		uint8_t e0 = pixels.e[RO(0)];
		uint8_t e1 = pixels.e[RO(1)];
    12be:	c2 85       	ldd	r28, Z+10	; 0x0a
		uint8_t e2 = pixels.e[RO(2)];
    12c0:	d3 85       	ldd	r29, Z+11	; 0x0b

		uint8_t loopvar=0;

		// This has to be done in asm to keep gcc from messing up the asm code further down
		b0 = data[RO(0)];
    12c2:	f6 01       	movw	r30, r12
    12c4:	10 81       	ld	r17, Z
		{
			LDSCL4(b0,O0) 	PRESCALEA2(d0)
    12c6:	a1 2c       	mov	r10, r1
    12c8:	0a 2d       	mov	r16, r10
    12ca:	2a 2d       	mov	r18, r10
    12cc:	3a 2d       	mov	r19, r10
    12ce:	30 81       	ld	r19, Z
    12d0:	11 27       	eor	r17, r17
    12d2:	88 94       	clc
    12d4:	31 11       	cpse	r19, r1
    12d6:	38 0f       	add	r19, r24
			PRESCALEB4(d0)	SCALE02(b0,0)
    12d8:	08 f4       	brcc	.+2      	; 0x12dc <L_2756>
    12da:	3f ef       	ldi	r19, 0xFF	; 255

000012dc <L_2756>:
    12dc:	81 95       	neg	r24
    12de:	88 94       	clc
    12e0:	90 fc       	sbrc	r9, 0
    12e2:	13 0f       	add	r17, r19
			RORSC04(b0,1) 	ROR1(b0) CLC1
    12e4:	17 95       	ror	r17
    12e6:	88 94       	clc
    12e8:	91 fc       	sbrc	r9, 1
    12ea:	13 0f       	add	r17, r19
    12ec:	17 95       	ror	r17
    12ee:	88 94       	clc
			SCROR04(b0,2)		SCALE02(b0,3)
    12f0:	92 fc       	sbrc	r9, 2
    12f2:	13 0f       	add	r17, r19
    12f4:	17 95       	ror	r17
    12f6:	88 94       	clc
    12f8:	93 fc       	sbrc	r9, 3
    12fa:	13 0f       	add	r17, r19
			RORSC04(b0,4) 	ROR1(b0) CLC1
    12fc:	17 95       	ror	r17
    12fe:	88 94       	clc
    1300:	94 fc       	sbrc	r9, 4
    1302:	13 0f       	add	r17, r19
    1304:	17 95       	ror	r17
    1306:	88 94       	clc
			SCROR04(b0,5) 	SCALE02(b0,6)
    1308:	95 fc       	sbrc	r9, 5
    130a:	13 0f       	add	r17, r19
    130c:	17 95       	ror	r17
    130e:	88 94       	clc
    1310:	96 fc       	sbrc	r9, 6
    1312:	13 0f       	add	r17, r19
			RORSC04(b0,7) 	ROR1(b0) CLC1
    1314:	17 95       	ror	r17
    1316:	88 94       	clc
    1318:	97 fc       	sbrc	r9, 7
    131a:	13 0f       	add	r17, r19
    131c:	17 95       	ror	r17
    131e:	88 94       	clc
			MOV_ADDDE04(b1,b0,d0,e0)
    1320:	03 2f       	mov	r16, r19
    1322:	91 10       	cpse	r9, r1
    1324:	01 2f       	mov	r16, r17
    1326:	86 0f       	add	r24, r22
			MOV1(b0,b1)
    1328:	10 2f       	mov	r17, r16

		{
			// while(--count)
			{
				// Loop beginning
				DNOP;
    132a:	00 2c       	mov	r0, r0
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
    132c:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    132e:	00 c0       	rjmp	.+0      	; 0x1330 <L_2756+0x54>
    1330:	00 c0       	rjmp	.+0      	; 0x1332 <L_2756+0x56>
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
    1332:	17 ff       	sbrs	r17, 7
    1334:	9b b9       	out	0x0b, r25	; 11
    1336:	31 81       	ldd	r19, Z+1	; 0x01
    1338:	00 27       	eor	r16, r16
    133a:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    133c:	00 c0       	rjmp	.+0      	; 0x133e <L_2756+0x62>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    133e:	00 2c       	mov	r0, r0
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
    1340:	9b b9       	out	0x0b, r25	; 11
    1342:	31 11       	cpse	r19, r1
    1344:	3f 0d       	add	r19, r15
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1346:	00 c0       	rjmp	.+0      	; 0x1348 <L_2756+0x6c>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1348:	00 2c       	mov	r0, r0
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
    134a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    134c:	00 c0       	rjmp	.+0      	; 0x134e <L_2756+0x72>
    134e:	00 c0       	rjmp	.+0      	; 0x1350 <L_2756+0x74>
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
    1350:	16 ff       	sbrs	r17, 6
    1352:	9b b9       	out	0x0b, r25	; 11
    1354:	08 f4       	brcc	.+2      	; 0x1358 <L_3300>
    1356:	3f ef       	ldi	r19, 0xFF	; 255

00001358 <L_3300>:
    1358:	f1 94       	neg	r15
    135a:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    135c:	00 c0       	rjmp	.+0      	; 0x135e <L_3300+0x6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    135e:	00 2c       	mov	r0, r0
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
    1360:	9b b9       	out	0x0b, r25	; 11
    1362:	40 fd       	sbrc	r20, 0
    1364:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1366:	00 c0       	rjmp	.+0      	; 0x1368 <L_3300+0x10>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1368:	00 2c       	mov	r0, r0

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
    136a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    136c:	00 c0       	rjmp	.+0      	; 0x136e <L_3300+0x16>
    136e:	00 c0       	rjmp	.+0      	; 0x1370 <L_3300+0x18>

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
    1370:	15 ff       	sbrs	r17, 5
    1372:	9b b9       	out	0x0b, r25	; 11
    1374:	07 95       	ror	r16
    1376:	88 94       	clc
    1378:	41 fd       	sbrc	r20, 1
    137a:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    137c:	00 c0       	rjmp	.+0      	; 0x137e <L_3300+0x26>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    137e:	00 2c       	mov	r0, r0

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
    1380:	9b b9       	out	0x0b, r25	; 11
    1382:	07 95       	ror	r16
    1384:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1386:	00 c0       	rjmp	.+0      	; 0x1388 <L_3300+0x30>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1388:	00 2c       	mov	r0, r0
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
    138a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    138c:	00 c0       	rjmp	.+0      	; 0x138e <L_3300+0x36>
    138e:	00 c0       	rjmp	.+0      	; 0x1390 <L_3300+0x38>
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
    1390:	14 ff       	sbrs	r17, 4
    1392:	9b b9       	out	0x0b, r25	; 11
    1394:	42 fd       	sbrc	r20, 2
    1396:	03 0f       	add	r16, r19
    1398:	07 95       	ror	r16
    139a:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    139c:	00 c0       	rjmp	.+0      	; 0x139e <L_3300+0x46>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    139e:	00 2c       	mov	r0, r0
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
    13a0:	9b b9       	out	0x0b, r25	; 11
    13a2:	43 fd       	sbrc	r20, 3
    13a4:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13a6:	00 c0       	rjmp	.+0      	; 0x13a8 <L_3300+0x50>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    13a8:	00 2c       	mov	r0, r0
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    13aa:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13ac:	00 c0       	rjmp	.+0      	; 0x13ae <L_3300+0x56>
    13ae:	00 c0       	rjmp	.+0      	; 0x13b0 <L_3300+0x58>
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    13b0:	13 ff       	sbrs	r17, 3
    13b2:	9b b9       	out	0x0b, r25	; 11
    13b4:	07 95       	ror	r16
    13b6:	88 94       	clc
    13b8:	44 fd       	sbrc	r20, 4
    13ba:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13bc:	00 c0       	rjmp	.+0      	; 0x13be <L_3300+0x66>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    13be:	00 2c       	mov	r0, r0
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    13c0:	9b b9       	out	0x0b, r25	; 11
    13c2:	07 95       	ror	r16
    13c4:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13c6:	00 c0       	rjmp	.+0      	; 0x13c8 <L_3300+0x70>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    13c8:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
    13ca:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13cc:	00 c0       	rjmp	.+0      	; 0x13ce <L_3300+0x76>
    13ce:	00 c0       	rjmp	.+0      	; 0x13d0 <L_3300+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
    13d0:	12 ff       	sbrs	r17, 2
    13d2:	9b b9       	out	0x0b, r25	; 11
    13d4:	45 fd       	sbrc	r20, 5
    13d6:	03 0f       	add	r16, r19
    13d8:	07 95       	ror	r16
    13da:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13dc:	00 c0       	rjmp	.+0      	; 0x13de <L_3300+0x86>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    13de:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
    13e0:	9b b9       	out	0x0b, r25	; 11
    13e2:	46 fd       	sbrc	r20, 6
    13e4:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13e6:	00 c0       	rjmp	.+0      	; 0x13e8 <L_3300+0x90>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    13e8:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    13ea:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13ec:	00 c0       	rjmp	.+0      	; 0x13ee <L_3300+0x96>
    13ee:	00 c0       	rjmp	.+0      	; 0x13f0 <L_3300+0x98>
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    13f0:	11 ff       	sbrs	r17, 1
    13f2:	9b b9       	out	0x0b, r25	; 11
    13f4:	07 95       	ror	r16
    13f6:	88 94       	clc
    13f8:	47 fd       	sbrc	r20, 7
    13fa:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    13fc:	00 c0       	rjmp	.+0      	; 0x13fe <L_3300+0xa6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    13fe:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    1400:	9b b9       	out	0x0b, r25	; 11
    1402:	07 95       	ror	r16
    1404:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1406:	00 c0       	rjmp	.+0      	; 0x1408 <L_3300+0xb0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1408:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    140a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    140c:	00 c0       	rjmp	.+0      	; 0x140e <L_3300+0xb6>
    140e:	00 c0       	rjmp	.+0      	; 0x1410 <L_3300+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    1410:	10 ff       	sbrs	r17, 0
    1412:	9b b9       	out	0x0b, r25	; 11
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)
    1414:	13 2f       	mov	r17, r19
    1416:	41 11       	cpse	r20, r1
    1418:	10 2f       	mov	r17, r16
    141a:	fc 0e       	add	r15, r28
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    141c:	00 c0       	rjmp	.+0      	; 0x141e <L_3300+0xc6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    141e:	00 2c       	mov	r0, r0
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)
    1420:	9b b9       	out	0x0b, r25	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1422:	00 c0       	rjmp	.+0      	; 0x1424 <L_3300+0xcc>
    1424:	00 c0       	rjmp	.+0      	; 0x1426 <L_3300+0xce>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1426:	00 2c       	mov	r0, r0
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
    1428:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    142a:	00 c0       	rjmp	.+0      	; 0x142c <L_3300+0xd4>
    142c:	00 c0       	rjmp	.+0      	; 0x142e <L_3300+0xd6>
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
    142e:	17 ff       	sbrs	r17, 7
    1430:	9b b9       	out	0x0b, r25	; 11
    1432:	32 81       	ldd	r19, Z+2	; 0x02
    1434:	00 27       	eor	r16, r16
    1436:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1438:	00 c0       	rjmp	.+0      	; 0x143a <L_3300+0xe2>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    143a:	00 2c       	mov	r0, r0
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
    143c:	9b b9       	out	0x0b, r25	; 11
    143e:	31 11       	cpse	r19, r1
    1440:	3e 0d       	add	r19, r14
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1442:	00 c0       	rjmp	.+0      	; 0x1444 <L_3300+0xec>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1444:	00 2c       	mov	r0, r0
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
    1446:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1448:	00 c0       	rjmp	.+0      	; 0x144a <L_3300+0xf2>
    144a:	00 c0       	rjmp	.+0      	; 0x144c <L_3300+0xf4>
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
    144c:	16 ff       	sbrs	r17, 6
    144e:	9b b9       	out	0x0b, r25	; 11
    1450:	08 f4       	brcc	.+2      	; 0x1454 <L_4518>
    1452:	3f ef       	ldi	r19, 0xFF	; 255

00001454 <L_4518>:
    1454:	e7 0f       	add	r30, r23
    1456:	f1 1d       	adc	r31, r1
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1458:	00 c0       	rjmp	.+0      	; 0x145a <L_4518+0x6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    145a:	00 2c       	mov	r0, r0
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
    145c:	9b b9       	out	0x0b, r25	; 11
    145e:	50 fd       	sbrc	r21, 0
    1460:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1462:	00 c0       	rjmp	.+0      	; 0x1464 <L_4518+0x10>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1464:	00 2c       	mov	r0, r0
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    1466:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1468:	00 c0       	rjmp	.+0      	; 0x146a <L_4518+0x16>
    146a:	00 c0       	rjmp	.+0      	; 0x146c <L_4518+0x18>
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    146c:	15 ff       	sbrs	r17, 5
    146e:	9b b9       	out	0x0b, r25	; 11
    1470:	07 95       	ror	r16
    1472:	88 94       	clc
    1474:	51 fd       	sbrc	r21, 1
    1476:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1478:	00 c0       	rjmp	.+0      	; 0x147a <L_4518+0x26>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    147a:	00 2c       	mov	r0, r0
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    147c:	9b b9       	out	0x0b, r25	; 11
    147e:	07 95       	ror	r16
    1480:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1482:	00 c0       	rjmp	.+0      	; 0x1484 <L_4518+0x30>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1484:	00 2c       	mov	r0, r0
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
    1486:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1488:	00 c0       	rjmp	.+0      	; 0x148a <L_4518+0x36>
    148a:	00 c0       	rjmp	.+0      	; 0x148c <L_4518+0x38>
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
    148c:	14 ff       	sbrs	r17, 4
    148e:	9b b9       	out	0x0b, r25	; 11
    1490:	52 fd       	sbrc	r21, 2
    1492:	03 0f       	add	r16, r19
    1494:	07 95       	ror	r16
    1496:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1498:	00 c0       	rjmp	.+0      	; 0x149a <L_4518+0x46>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    149a:	00 2c       	mov	r0, r0
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
    149c:	9b b9       	out	0x0b, r25	; 11
    149e:	53 fd       	sbrc	r21, 3
    14a0:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14a2:	00 c0       	rjmp	.+0      	; 0x14a4 <L_4518+0x50>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    14a4:	00 2c       	mov	r0, r0

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    14a6:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14a8:	00 c0       	rjmp	.+0      	; 0x14aa <L_4518+0x56>
    14aa:	00 c0       	rjmp	.+0      	; 0x14ac <L_4518+0x58>

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    14ac:	13 ff       	sbrs	r17, 3
    14ae:	9b b9       	out	0x0b, r25	; 11
    14b0:	07 95       	ror	r16
    14b2:	88 94       	clc
    14b4:	54 fd       	sbrc	r21, 4
    14b6:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14b8:	00 c0       	rjmp	.+0      	; 0x14ba <L_4518+0x66>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    14ba:	00 2c       	mov	r0, r0

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    14bc:	9b b9       	out	0x0b, r25	; 11
    14be:	07 95       	ror	r16
    14c0:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14c2:	00 c0       	rjmp	.+0      	; 0x14c4 <L_4518+0x70>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    14c4:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
    14c6:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14c8:	00 c0       	rjmp	.+0      	; 0x14ca <L_4518+0x76>
    14ca:	00 c0       	rjmp	.+0      	; 0x14cc <L_4518+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
    14cc:	12 ff       	sbrs	r17, 2
    14ce:	9b b9       	out	0x0b, r25	; 11
    14d0:	55 fd       	sbrc	r21, 5
    14d2:	03 0f       	add	r16, r19
    14d4:	07 95       	ror	r16
    14d6:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14d8:	00 c0       	rjmp	.+0      	; 0x14da <L_4518+0x86>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    14da:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
    14dc:	9b b9       	out	0x0b, r25	; 11
    14de:	56 fd       	sbrc	r21, 6
    14e0:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14e2:	00 c0       	rjmp	.+0      	; 0x14e4 <L_4518+0x90>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    14e4:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    14e6:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14e8:	00 c0       	rjmp	.+0      	; 0x14ea <L_4518+0x96>
    14ea:	00 c0       	rjmp	.+0      	; 0x14ec <L_4518+0x98>
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    14ec:	11 ff       	sbrs	r17, 1
    14ee:	9b b9       	out	0x0b, r25	; 11
    14f0:	07 95       	ror	r16
    14f2:	88 94       	clc
    14f4:	57 fd       	sbrc	r21, 7
    14f6:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    14f8:	00 c0       	rjmp	.+0      	; 0x14fa <L_4518+0xa6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    14fa:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    14fc:	9b b9       	out	0x0b, r25	; 11
    14fe:	07 95       	ror	r16
    1500:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1502:	00 c0       	rjmp	.+0      	; 0x1504 <L_4518+0xb0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1504:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    1506:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1508:	00 c0       	rjmp	.+0      	; 0x150a <L_4518+0xb6>
    150a:	00 c0       	rjmp	.+0      	; 0x150c <L_4518+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    150c:	10 ff       	sbrs	r17, 0
    150e:	9b b9       	out	0x0b, r25	; 11
				}

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
    1510:	13 2f       	mov	r17, r19
    1512:	51 11       	cpse	r21, r1
    1514:	10 2f       	mov	r17, r16
    1516:	e1 94       	neg	r14
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1518:	00 c0       	rjmp	.+0      	; 0x151a <L_4518+0xc6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    151a:	00 2c       	mov	r0, r0
				}

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
    151c:	9b b9       	out	0x0b, r25	; 11
    151e:	ed 0e       	add	r14, r29
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1520:	00 c0       	rjmp	.+0      	; 0x1522 <L_4518+0xce>
    1522:	00 c0       	rjmp	.+0      	; 0x1524 <L_4518+0xd0>

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
    1524:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1526:	00 c0       	rjmp	.+0      	; 0x1528 <L_4518+0xd4>
    1528:	00 c0       	rjmp	.+0      	; 0x152a <L_4518+0xd6>

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
    152a:	17 ff       	sbrs	r17, 7
    152c:	9b b9       	out	0x0b, r25	; 11
    152e:	30 81       	ld	r19, Z
    1530:	00 27       	eor	r16, r16
    1532:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1534:	00 c0       	rjmp	.+0      	; 0x1536 <L_4518+0xe2>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1536:	00 2c       	mov	r0, r0

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
    1538:	9b b9       	out	0x0b, r25	; 11
    153a:	31 11       	cpse	r19, r1
    153c:	38 0f       	add	r19, r24
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    153e:	00 c0       	rjmp	.+0      	; 0x1540 <L_4518+0xec>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1540:	00 2c       	mov	r0, r0
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
    1542:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1544:	00 c0       	rjmp	.+0      	; 0x1546 <L_4518+0xf2>
    1546:	00 c0       	rjmp	.+0      	; 0x1548 <L_4518+0xf4>
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
    1548:	16 ff       	sbrs	r17, 6
    154a:	9b b9       	out	0x0b, r25	; 11
    154c:	08 f4       	brcc	.+2      	; 0x1550 <L_5742>
    154e:	3f ef       	ldi	r19, 0xFF	; 255

00001550 <L_5742>:
    1550:	81 95       	neg	r24
    1552:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1554:	00 c0       	rjmp	.+0      	; 0x1556 <L_5742+0x6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1556:	00 2c       	mov	r0, r0
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
    1558:	9b b9       	out	0x0b, r25	; 11
    155a:	90 fc       	sbrc	r9, 0
    155c:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    155e:	00 c0       	rjmp	.+0      	; 0x1560 <L_5742+0x10>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1560:	00 2c       	mov	r0, r0
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    1562:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1564:	00 c0       	rjmp	.+0      	; 0x1566 <L_5742+0x16>
    1566:	00 c0       	rjmp	.+0      	; 0x1568 <L_5742+0x18>
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    1568:	15 ff       	sbrs	r17, 5
    156a:	9b b9       	out	0x0b, r25	; 11
    156c:	07 95       	ror	r16
    156e:	88 94       	clc
    1570:	91 fc       	sbrc	r9, 1
    1572:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1574:	00 c0       	rjmp	.+0      	; 0x1576 <L_5742+0x26>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1576:	00 2c       	mov	r0, r0
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    1578:	9b b9       	out	0x0b, r25	; 11
    157a:	07 95       	ror	r16
    157c:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    157e:	00 c0       	rjmp	.+0      	; 0x1580 <L_5742+0x30>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1580:	00 2c       	mov	r0, r0
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
    1582:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1584:	00 c0       	rjmp	.+0      	; 0x1586 <L_5742+0x36>
    1586:	00 c0       	rjmp	.+0      	; 0x1588 <L_5742+0x38>
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
    1588:	14 ff       	sbrs	r17, 4
    158a:	9b b9       	out	0x0b, r25	; 11
    158c:	92 fc       	sbrc	r9, 2
    158e:	03 0f       	add	r16, r19
    1590:	07 95       	ror	r16
    1592:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1594:	00 c0       	rjmp	.+0      	; 0x1596 <L_5742+0x46>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1596:	00 2c       	mov	r0, r0
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
    1598:	9b b9       	out	0x0b, r25	; 11
    159a:	93 fc       	sbrc	r9, 3
    159c:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    159e:	00 c0       	rjmp	.+0      	; 0x15a0 <L_5742+0x50>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    15a0:	00 2c       	mov	r0, r0
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
    15a2:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15a4:	00 c0       	rjmp	.+0      	; 0x15a6 <L_5742+0x56>
    15a6:	00 c0       	rjmp	.+0      	; 0x15a8 <L_5742+0x58>
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
    15a8:	13 ff       	sbrs	r17, 3
    15aa:	9b b9       	out	0x0b, r25	; 11
    15ac:	07 95       	ror	r16
    15ae:	88 94       	clc
    15b0:	94 fc       	sbrc	r9, 4
    15b2:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15b4:	00 c0       	rjmp	.+0      	; 0x15b6 <L_5742+0x66>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    15b6:	00 2c       	mov	r0, r0
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
    15b8:	9b b9       	out	0x0b, r25	; 11
    15ba:	07 95       	ror	r16
    15bc:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15be:	00 c0       	rjmp	.+0      	; 0x15c0 <L_5742+0x70>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    15c0:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
    15c2:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15c4:	00 c0       	rjmp	.+0      	; 0x15c6 <L_5742+0x76>
    15c6:	00 c0       	rjmp	.+0      	; 0x15c8 <L_5742+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
    15c8:	12 ff       	sbrs	r17, 2
    15ca:	9b b9       	out	0x0b, r25	; 11
    15cc:	95 fc       	sbrc	r9, 5
    15ce:	03 0f       	add	r16, r19
    15d0:	07 95       	ror	r16
    15d2:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15d4:	00 c0       	rjmp	.+0      	; 0x15d6 <L_5742+0x86>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    15d6:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
    15d8:	9b b9       	out	0x0b, r25	; 11
    15da:	96 fc       	sbrc	r9, 6
    15dc:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15de:	00 c0       	rjmp	.+0      	; 0x15e0 <L_5742+0x90>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    15e0:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    15e2:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15e4:	00 c0       	rjmp	.+0      	; 0x15e6 <L_5742+0x96>
    15e6:	00 c0       	rjmp	.+0      	; 0x15e8 <L_5742+0x98>
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    15e8:	11 ff       	sbrs	r17, 1
    15ea:	9b b9       	out	0x0b, r25	; 11
    15ec:	07 95       	ror	r16
    15ee:	88 94       	clc
    15f0:	97 fc       	sbrc	r9, 7
    15f2:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15f4:	00 c0       	rjmp	.+0      	; 0x15f6 <L_5742+0xa6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    15f6:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
    15f8:	9b b9       	out	0x0b, r25	; 11
    15fa:	07 95       	ror	r16
    15fc:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    15fe:	00 c0       	rjmp	.+0      	; 0x1600 <L_5742+0xb0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1600:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    1602:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1604:	00 c0       	rjmp	.+0      	; 0x1606 <L_5742+0xb6>
    1606:	00 c0       	rjmp	.+0      	; 0x1608 <L_5742+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
    1608:	10 ff       	sbrs	r17, 0
    160a:	9b b9       	out	0x0b, r25	; 11
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE04(b0,b1,d0,e0) D2(4) LO1 D3(5)
    160c:	13 2f       	mov	r17, r19
    160e:	91 10       	cpse	r9, r1
    1610:	10 2f       	mov	r17, r16
    1612:	86 0f       	add	r24, r22
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
    1614:	00 c0       	rjmp	.+0      	; 0x1616 <L_5742+0xc6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
    1616:	00 2c       	mov	r0, r0
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE04(b0,b1,d0,e0) D2(4) LO1 D3(5)
    1618:	9b b9       	out	0x0b, r25	; 11
				ENDLOOP5
    161a:	11 97       	sbiw	r26, 0x01	; 1
    161c:	09 f0       	breq	.+2      	; 0x1620 <L_6711>
    161e:	86 ce       	rjmp	.-756    	; 0x132c <L_2756+0x50>

00001620 <L_6711>:

		#if (FASTLED_ALLOW_INTERRUPTS == 1)
		// stop using the clock juggler
		TCCR0A &= ~0x30;
		#endif
	}
    1620:	df 91       	pop	r29
    1622:	cf 91       	pop	r28
    1624:	1f 91       	pop	r17
    1626:	0f 91       	pop	r16
    1628:	ff 90       	pop	r15
    162a:	ef 90       	pop	r14
    162c:	df 90       	pop	r13
    162e:	cf 90       	pop	r12
    1630:	bf 90       	pop	r11
    1632:	af 90       	pop	r10
    1634:	9f 90       	pop	r9
    1636:	08 95       	ret

00001638 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_10ELi1ELm4294967295EE>:

	virtual uint16_t getMaxRefreshRate() const { return 400; }

protected:

	virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
    1638:	0f 93       	push	r16
    163a:	1f 93       	push	r17
    163c:	cf 93       	push	r28
    163e:	df 93       	push	r29
    1640:	ec 01       	movw	r28, r24
    1642:	8b 01       	movw	r16, r22

	void wait() {
		uint16_t diff;
		do {
			diff = (micros() & 0xFFFF) - mLastMicros;
    1644:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
public:
	CMinWait() { mLastMicros = 0; }

	void wait() {
		uint16_t diff;
		do {
    1648:	2f 85       	ldd	r18, Y+15	; 0x0f
    164a:	38 89       	ldd	r19, Y+16	; 0x10
    164c:	62 1b       	sub	r22, r18
    164e:	73 0b       	sbc	r23, r19
    1650:	6a 30       	cpi	r22, 0x0A	; 10
    1652:	71 05       	cpc	r23, r1
    1654:	b8 f3       	brcs	.-18     	; 0x1644 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_10ELi1ELm4294967295EE+0xc>

		mWait.wait();
		cli();
    1656:	f8 94       	cli

		showRGBInternal(pixels);
    1658:	c8 01       	movw	r24, r16
    165a:	0e 94 38 09 	call	0x1270	; 0x1270 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE15showRGBInternalER15PixelControllerILS0_10ELi1ELm4294967295EE>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
            }
        }

        __attribute__((always_inline)) inline int size() { return mLen; }
    165e:	f8 01       	movw	r30, r16
    1660:	42 81       	ldd	r20, Z+2	; 0x02
    1662:	53 81       	ldd	r21, Z+3	; 0x03

		// Adjust the timer
#if (!defined(NO_CORRECTION) || (NO_CORRECTION == 0)) && (FASTLED_ALLOW_INTERRUPTS == 0)
        uint32_t microsTaken = (uint32_t)pixels.size() * (uint32_t)CLKS_TO_MICROS(24 * (T1 + T2 + T3));
    1664:	20 ee       	ldi	r18, 0xE0	; 224
    1666:	31 e0       	ldi	r19, 0x01	; 1
    1668:	da 01       	movw	r26, r20
    166a:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <__usmulhisi3>
    166e:	dc 01       	movw	r26, r24
    1670:	cb 01       	movw	r24, r22
    1672:	f4 e0       	ldi	r31, 0x04	; 4
    1674:	b6 95       	lsr	r27
    1676:	a7 95       	ror	r26
    1678:	97 95       	ror	r25
    167a:	87 95       	ror	r24
    167c:	fa 95       	dec	r31
    167e:	d1 f7       	brne	.-12     	; 0x1674 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_10ELi1ELm4294967295EE+0x3c>
                 "  adc %B[result], __zero_reg__        \n\t"

                 : [result] "+r" (result)
                 : [i] "r" (i), [scale] "r" (scale)
                 : "r0", "r1"
                 );
    1680:	20 e0       	ldi	r18, 0x00	; 0
    1682:	30 e0       	ldi	r19, 0x00	; 0
    1684:	b9 01       	movw	r22, r18
    1686:	ea e9       	ldi	r30, 0x9A	; 154
    1688:	4e 9f       	mul	r20, r30
    168a:	04 0e       	add	r0, r20
    168c:	61 1d       	adc	r22, r1
    168e:	5e 9f       	mul	r21, r30
    1690:	60 0d       	add	r22, r0
    1692:	71 1d       	adc	r23, r1
    1694:	11 24       	eor	r1, r1
    1696:	65 0f       	add	r22, r21
    1698:	71 1d       	adc	r23, r1

        // adust for approximate observed actal runtime (as of January 2015)
        // roughly 9.6 cycles per pixel, which is 0.6us/pixel at 16MHz
        // microsTaken += nLeds * 0.6 * CLKS_TO_MICROS(16);
        microsTaken += scale16by8(pixels.size(),(0.6 * 256) + 1) * CLKS_TO_MICROS(16);
    169a:	86 0f       	add	r24, r22
    169c:	97 1f       	adc	r25, r23
    169e:	a1 1d       	adc	r26, r1
    16a0:	b1 1d       	adc	r27, r1
        // this is because the ONE interrupt that might come in while interrupts
        // are disabled is queued up, and it will be serviced as soon as
        // interrupts are re-enabled.
        // This actually should technically also account for the runtime of the
        // interrupt handler itself, but we're just not going to worry about that.
        if( microsTaken > 1000) {
    16a2:	89 3e       	cpi	r24, 0xE9	; 233
    16a4:	f3 e0       	ldi	r31, 0x03	; 3
    16a6:	9f 07       	cpc	r25, r31
    16a8:	a1 05       	cpc	r26, r1
    16aa:	b1 05       	cpc	r27, r1
    16ac:	08 f4       	brcc	.+2      	; 0x16b0 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_10ELi1ELm4294967295EE+0x78>
    16ae:	34 c0       	rjmp	.+104    	; 0x1718 <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_10ELi1ELm4294967295EE+0xe0>
            microsTaken -= 1000;

            // Now convert microseconds to 256ths of a second, approximately like this:
            // 250ths = (us/4)
            // 256ths = 250ths * (263/256);
            uint16_t x256ths = microsTaken >> 2;
    16b0:	88 5e       	subi	r24, 0xE8	; 232
    16b2:	93 40       	sbci	r25, 0x03	; 3
    16b4:	a1 09       	sbc	r26, r1
    16b6:	b1 09       	sbc	r27, r1
    16b8:	42 e0       	ldi	r20, 0x02	; 2
    16ba:	b6 95       	lsr	r27
    16bc:	a7 95       	ror	r26
    16be:	97 95       	ror	r25
    16c0:	87 95       	ror	r24
    16c2:	4a 95       	dec	r20
    16c4:	d1 f7       	brne	.-12     	; 0x16ba <_ZN19ClocklessControllerILh3ELi6ELi8ELi6EL6EOrder10ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_10ELi1ELm4294967295EE+0x82>
    16c6:	47 e0       	ldi	r20, 0x07	; 7
    16c8:	84 9f       	mul	r24, r20
    16ca:	08 0e       	add	r0, r24
    16cc:	21 1d       	adc	r18, r1
    16ce:	94 9f       	mul	r25, r20
    16d0:	20 0d       	add	r18, r0
    16d2:	31 1d       	adc	r19, r1
    16d4:	11 24       	eor	r1, r1
    16d6:	29 0f       	add	r18, r25
    16d8:	31 1d       	adc	r19, r1
    16da:	60 91 4d 05 	lds	r22, 0x054D	; 0x80054d <_ZL21gTimeErrorAccum256ths>
    16de:	70 e0       	ldi	r23, 0x00	; 0
    16e0:	86 0f       	add	r24, r22
    16e2:	97 1f       	adc	r25, r23
            x256ths += scale16by8(x256ths,7);

            x256ths += gTimeErrorAccum256ths;
    16e4:	82 0f       	add	r24, r18
    16e6:	93 1f       	adc	r25, r19
            MS_COUNTER += (x256ths >> 8);
    16e8:	40 91 4f 05 	lds	r20, 0x054F	; 0x80054f <timer0_millis>
    16ec:	50 91 50 05 	lds	r21, 0x0550	; 0x800550 <timer0_millis+0x1>
    16f0:	60 91 51 05 	lds	r22, 0x0551	; 0x800551 <timer0_millis+0x2>
    16f4:	70 91 52 05 	lds	r23, 0x0552	; 0x800552 <timer0_millis+0x3>
    16f8:	29 2f       	mov	r18, r25
    16fa:	33 27       	eor	r19, r19
    16fc:	42 0f       	add	r20, r18
    16fe:	53 1f       	adc	r21, r19
    1700:	61 1d       	adc	r22, r1
    1702:	71 1d       	adc	r23, r1
    1704:	40 93 4f 05 	sts	0x054F, r20	; 0x80054f <timer0_millis>
    1708:	50 93 50 05 	sts	0x0550, r21	; 0x800550 <timer0_millis+0x1>
    170c:	60 93 51 05 	sts	0x0551, r22	; 0x800551 <timer0_millis+0x2>
    1710:	70 93 52 05 	sts	0x0552, r23	; 0x800552 <timer0_millis+0x3>
            gTimeErrorAccum256ths = x256ths & 0xFF;
    1714:	80 93 4d 05 	sts	0x054D, r24	; 0x80054d <_ZL21gTimeErrorAccum256ths>
        MS_COUNTER += (microsTaken >> 10);
#endif

#endif

		sei();
    1718:	78 94       	sei
			diff = (micros() & 0xFFFF) - mLastMicros;
		} while(diff < WAIT);
	}

	void mark() { mLastMicros = micros() & 0xFFFF; }
    171a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
    171e:	78 8b       	std	Y+16, r23	; 0x10
    1720:	6f 87       	std	Y+15, r22	; 0x0f
		mWait.mark();
	}
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	1f 91       	pop	r17
    1728:	0f 91       	pop	r16
    172a:	08 95       	ret

0000172c <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE11initOffsetsEi>:
        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
            mOffsets[i] = nOffset;
    172c:	fc 01       	movw	r30, r24
    172e:	11 8a       	std	Z+17, r1	; 0x11
    1730:	10 8a       	std	Z+16, r1	; 0x10
    1732:	08 95       	ret

00001734 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv>:
            enable_dithering(dither);
            mAdvance = 0;
            initOffsets(len);
        }

        void init_binary_dithering() {
    1734:	0f 93       	push	r16
    1736:	1f 93       	push	r17
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
    173c:	20 91 e7 02 	lds	r18, 0x02E7	; 0x8002e7 <_ZZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEvE1R>
    1740:	2f 5f       	subi	r18, 0xFF	; 255
    1742:	32 2f       	mov	r19, r18
    1744:	37 70       	andi	r19, 0x07	; 7
    1746:	30 93 e7 02 	sts	0x02E7, r19	; 0x8002e7 <_ZZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEvE1R>
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
    174a:	20 ff       	sbrs	r18, 0
    174c:	02 c0       	rjmp	.+4      	; 0x1752 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x1e>
    174e:	20 e8       	ldi	r18, 0x80	; 128
    1750:	01 c0       	rjmp	.+2      	; 0x1754 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x20>
            R &= (0x01 << ditherBits) - 1;

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;
    1752:	20 e0       	ldi	r18, 0x00	; 0

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
                if(R & 0x02) { Q |= 0x40; }
    1754:	31 fd       	sbrc	r19, 1
    1756:	20 64       	ori	r18, 0x40	; 64
                if(R & 0x04) { Q |= 0x20; }
    1758:	34 70       	andi	r19, 0x04	; 4
    175a:	09 f0       	breq	.+2      	; 0x175e <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x2a>
    175c:	20 62       	ori	r18, 0x20	; 32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
    175e:	20 5f       	subi	r18, 0xF0	; 240
    1760:	fc 01       	movw	r30, r24
    1762:	ec 01       	movw	r28, r24
    1764:	23 96       	adiw	r28, 0x03	; 3
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
    1766:	00 e0       	ldi	r16, 0x00	; 0
    1768:	11 e0       	ldi	r17, 0x01	; 1
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
    176a:	64 85       	ldd	r22, Z+12	; 0x0c
                    e[i] = s ? (256/s) + 1 : 0;
    176c:	66 23       	and	r22, r22
    176e:	31 f0       	breq	.+12     	; 0x177c <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x48>
    1770:	70 e0       	ldi	r23, 0x00	; 0
    1772:	c8 01       	movw	r24, r16
    1774:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <__divmodhi4>
    1778:	6f 5f       	subi	r22, 0xFF	; 255
    177a:	01 c0       	rjmp	.+2      	; 0x177e <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x4a>
    177c:	60 e0       	ldi	r22, 0x00	; 0
    177e:	61 87       	std	Z+9, r22	; 0x09
#endif
         "clr __zero_reg__    \n\t"

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
    1780:	32 2f       	mov	r19, r18
    1782:	36 9f       	mul	r19, r22
    1784:	03 0e       	add	r0, r19
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	31 1d       	adc	r19, r1
    178a:	11 24       	eor	r1, r1
                    d[i] = scale8(Q, e[i]);
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
    178c:	31 11       	cpse	r19, r1
    178e:	02 c0       	rjmp	.+4      	; 0x1794 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x60>

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
                    d[i] = scale8(Q, e[i]);
    1790:	16 82       	std	Z+6, r1	; 0x06
    1792:	02 c0       	rjmp	.+4      	; 0x1798 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x64>
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
    1794:	31 50       	subi	r19, 0x01	; 1
    1796:	36 83       	std	Z+6, r19	; 0x06
#endif
                    if(e[i]) e[i]--;
    1798:	66 23       	and	r22, r22
    179a:	11 f0       	breq	.+4      	; 0x17a0 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x6c>
    179c:	61 50       	subi	r22, 0x01	; 1
    179e:	61 87       	std	Z+9, r22	; 0x09
    17a0:	31 96       	adiw	r30, 0x01	; 1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
    17a2:	ce 17       	cp	r28, r30
    17a4:	df 07       	cpc	r29, r31
    17a6:	09 f7       	brne	.-62     	; 0x176a <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv+0x36>
                    if(d[i]) (d[i]--);
#endif
                    if(e[i]) e[i]--;
            }
#endif
        }
    17a8:	df 91       	pop	r29
    17aa:	cf 91       	pop	r28
    17ac:	1f 91       	pop	r17
    17ae:	0f 91       	pop	r16
    17b0:	08 95       	ret

000017b2 <_ZN19CPixelLEDControllerIL6EOrder10ELi1ELm4294967295EE4showEPK4CRGBiS2_>:

/// write the passed in rgb data out to the leds managed by this controller
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
    17b2:	ef 92       	push	r14
    17b4:	ff 92       	push	r15
    17b6:	0f 93       	push	r16
    17b8:	1f 93       	push	r17
    17ba:	cf 93       	push	r28
    17bc:	df 93       	push	r29
    17be:	cd b7       	in	r28, 0x3d	; 61
    17c0:	de b7       	in	r29, 0x3e	; 62
    17c2:	62 97       	sbiw	r28, 0x12	; 18
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	de bf       	out	0x3e, r29	; 62
    17ca:	0f be       	out	0x3f, r0	; 63
    17cc:	cd bf       	out	0x3d, r28	; 61
    17ce:	8c 01       	movw	r16, r24
    17d0:	7a 01       	movw	r14, r20
    17d2:	f9 01       	movw	r30, r18
    17d4:	dc 01       	movw	r26, r24
    17d6:	1c 96       	adiw	r26, 0x0c	; 12
    17d8:	8c 91       	ld	r24, X
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
    17da:	7a 83       	std	Y+2, r23	; 0x02
    17dc:	69 83       	std	Y+1, r22	; 0x01
    17de:	5c 83       	std	Y+4, r21	; 0x04
    17e0:	4b 83       	std	Y+3, r20	; 0x03
    17e2:	5e 83       	std	Y+6, r21	; 0x06
    17e4:	4d 83       	std	Y+5, r20	; 0x05
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    17e6:	90 81       	ld	r25, Z
    17e8:	9d 87       	std	Y+13, r25	; 0x0d
        g = rhs.g;
    17ea:	91 81       	ldd	r25, Z+1	; 0x01
    17ec:	9e 87       	std	Y+14, r25	; 0x0e
        b = rhs.b;
    17ee:	92 81       	ldd	r25, Z+2	; 0x02
    17f0:	9f 87       	std	Y+15, r25	; 0x0f
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
    17f2:	81 30       	cpi	r24, 0x01	; 1
    17f4:	29 f4       	brne	.+10     	; 0x1800 <_ZN19CPixelLEDControllerIL6EOrder10ELi1ELm4294967295EE4showEPK4CRGBiS2_+0x4e>
                case BINARY_DITHER: init_binary_dithering(); break;
    17f6:	ce 01       	movw	r24, r28
    17f8:	01 96       	adiw	r24, 0x01	; 1
    17fa:	0e 94 9a 0b 	call	0x1734	; 0x1734 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv>
    17fe:	06 c0       	rjmp	.+12     	; 0x180c <_ZN19CPixelLEDControllerIL6EOrder10ELi1ELm4294967295EE4showEPK4CRGBiS2_+0x5a>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
    1800:	1c 86       	std	Y+12, r1	; 0x0c
    1802:	1b 86       	std	Y+11, r1	; 0x0b
    1804:	1a 86       	std	Y+10, r1	; 0x0a
    1806:	19 86       	std	Y+9, r1	; 0x09
    1808:	18 86       	std	Y+8, r1	; 0x08
    180a:	1f 82       	std	Y+7, r1	; 0x07
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
    180c:	83 e0       	ldi	r24, 0x03	; 3
    180e:	88 8b       	std	Y+16, r24	; 0x10
            initOffsets(len);
    1810:	b7 01       	movw	r22, r14
    1812:	ce 01       	movw	r24, r28
    1814:	01 96       	adiw	r24, 0x01	; 1
    1816:	0e 94 96 0b 	call	0x172c	; 0x172c <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE11initOffsetsEi>
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
    181a:	d8 01       	movw	r26, r16
    181c:	ed 91       	ld	r30, X+
    181e:	fc 91       	ld	r31, X
    1820:	04 84       	ldd	r0, Z+12	; 0x0c
    1822:	f5 85       	ldd	r31, Z+13	; 0x0d
    1824:	e0 2d       	mov	r30, r0
    1826:	be 01       	movw	r22, r28
    1828:	6f 5f       	subi	r22, 0xFF	; 255
    182a:	7f 4f       	sbci	r23, 0xFF	; 255
    182c:	c8 01       	movw	r24, r16
    182e:	09 95       	icall
  }
    1830:	62 96       	adiw	r28, 0x12	; 18
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	f8 94       	cli
    1836:	de bf       	out	0x3e, r29	; 62
    1838:	0f be       	out	0x3f, r0	; 63
    183a:	cd bf       	out	0x3d, r28	; 61
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	08 95       	ret

0000184a <_ZN19CPixelLEDControllerIL6EOrder10ELi1ELm4294967295EE9showColorERK4CRGBiS2_>:

  /// set all the leds on the controller to a given color
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    184a:	ef 92       	push	r14
    184c:	ff 92       	push	r15
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	cd b7       	in	r28, 0x3d	; 61
    1858:	de b7       	in	r29, 0x3e	; 62
    185a:	62 97       	sbiw	r28, 0x12	; 18
    185c:	0f b6       	in	r0, 0x3f	; 63
    185e:	f8 94       	cli
    1860:	de bf       	out	0x3e, r29	; 62
    1862:	0f be       	out	0x3f, r0	; 63
    1864:	cd bf       	out	0x3d, r28	; 61
    1866:	8c 01       	movw	r16, r24
    1868:	7a 01       	movw	r14, r20
    186a:	f9 01       	movw	r30, r18
    186c:	dc 01       	movw	r26, r24
    186e:	1c 96       	adiw	r26, 0x0c	; 12
    1870:	8c 91       	ld	r24, X
            enable_dithering(dither);
            mAdvance = 3;
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
    1872:	7a 83       	std	Y+2, r23	; 0x02
    1874:	69 83       	std	Y+1, r22	; 0x01
    1876:	5c 83       	std	Y+4, r21	; 0x04
    1878:	4b 83       	std	Y+3, r20	; 0x03
    187a:	5e 83       	std	Y+6, r21	; 0x06
    187c:	4d 83       	std	Y+5, r20	; 0x05
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
    187e:	90 81       	ld	r25, Z
    1880:	9d 87       	std	Y+13, r25	; 0x0d
        g = rhs.g;
    1882:	91 81       	ldd	r25, Z+1	; 0x01
    1884:	9e 87       	std	Y+14, r25	; 0x0e
        b = rhs.b;
    1886:	92 81       	ldd	r25, Z+2	; 0x02
    1888:	9f 87       	std	Y+15, r25	; 0x0f
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
    188a:	81 30       	cpi	r24, 0x01	; 1
    188c:	29 f4       	brne	.+10     	; 0x1898 <_ZN19CPixelLEDControllerIL6EOrder10ELi1ELm4294967295EE9showColorERK4CRGBiS2_+0x4e>
                case BINARY_DITHER: init_binary_dithering(); break;
    188e:	ce 01       	movw	r24, r28
    1890:	01 96       	adiw	r24, 0x01	; 1
    1892:	0e 94 9a 0b 	call	0x1734	; 0x1734 <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE21init_binary_ditheringEv>
    1896:	06 c0       	rjmp	.+12     	; 0x18a4 <_ZN19CPixelLEDControllerIL6EOrder10ELi1ELm4294967295EE9showColorERK4CRGBiS2_+0x5a>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
    1898:	1c 86       	std	Y+12, r1	; 0x0c
    189a:	1b 86       	std	Y+11, r1	; 0x0b
    189c:	1a 86       	std	Y+10, r1	; 0x0a
    189e:	19 86       	std	Y+9, r1	; 0x09
    18a0:	18 86       	std	Y+8, r1	; 0x08
    18a2:	1f 82       	std	Y+7, r1	; 0x07
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
    18a4:	18 8a       	std	Y+16, r1	; 0x10
            initOffsets(len);
    18a6:	b7 01       	movw	r22, r14
    18a8:	ce 01       	movw	r24, r28
    18aa:	01 96       	adiw	r24, 0x01	; 1
    18ac:	0e 94 96 0b 	call	0x172c	; 0x172c <_ZN15PixelControllerIL6EOrder10ELi1ELm4294967295EE11initOffsetsEi>
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
    18b0:	d8 01       	movw	r26, r16
    18b2:	ed 91       	ld	r30, X+
    18b4:	fc 91       	ld	r31, X
    18b6:	04 84       	ldd	r0, Z+12	; 0x0c
    18b8:	f5 85       	ldd	r31, Z+13	; 0x0d
    18ba:	e0 2d       	mov	r30, r0
    18bc:	be 01       	movw	r22, r28
    18be:	6f 5f       	subi	r22, 0xFF	; 255
    18c0:	7f 4f       	sbci	r23, 0xFF	; 255
    18c2:	c8 01       	movw	r24, r16
    18c4:	09 95       	icall
  }
    18c6:	62 96       	adiw	r28, 0x12	; 18
    18c8:	0f b6       	in	r0, 0x3f	; 63
    18ca:	f8 94       	cli
    18cc:	de bf       	out	0x3e, r29	; 62
    18ce:	0f be       	out	0x3f, r0	; 63
    18d0:	cd bf       	out	0x3d, r28	; 61
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	1f 91       	pop	r17
    18d8:	0f 91       	pop	r16
    18da:	ff 90       	pop	r15
    18dc:	ef 90       	pop	r14
    18de:	08 95       	ret

000018e0 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    18e0:	08 95       	ret

000018e2 <initVariant>:
    18e2:	08 95       	ret

000018e4 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    18e4:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <init>

	initVariant();
    18e8:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    18ec:	0e 94 55 03 	call	0x6aa	; 0x6aa <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    18f0:	c0 e0       	ldi	r28, 0x00	; 0
    18f2:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
    18f4:	0e 94 b6 03 	call	0x76c	; 0x76c <loop>
		if (serialEventRun) serialEventRun();
    18f8:	20 97       	sbiw	r28, 0x00	; 0
    18fa:	e1 f3       	breq	.-8      	; 0x18f4 <main+0x10>
    18fc:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    1900:	f9 cf       	rjmp	.-14     	; 0x18f4 <main+0x10>

00001902 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
    1902:	1f 92       	push	r1
    1904:	0f 92       	push	r0
    1906:	0f b6       	in	r0, 0x3f	; 63
    1908:	0f 92       	push	r0
    190a:	11 24       	eor	r1, r1
    190c:	2f 93       	push	r18
    190e:	3f 93       	push	r19
    1910:	8f 93       	push	r24
    1912:	9f 93       	push	r25
    1914:	af 93       	push	r26
    1916:	bf 93       	push	r27
    1918:	80 91 4f 05 	lds	r24, 0x054F	; 0x80054f <timer0_millis>
    191c:	90 91 50 05 	lds	r25, 0x0550	; 0x800550 <timer0_millis+0x1>
    1920:	a0 91 51 05 	lds	r26, 0x0551	; 0x800551 <timer0_millis+0x2>
    1924:	b0 91 52 05 	lds	r27, 0x0552	; 0x800552 <timer0_millis+0x3>
    1928:	30 91 4e 05 	lds	r19, 0x054E	; 0x80054e <timer0_fract>
    192c:	23 e0       	ldi	r18, 0x03	; 3
    192e:	23 0f       	add	r18, r19
    1930:	2d 37       	cpi	r18, 0x7D	; 125
    1932:	20 f4       	brcc	.+8      	; 0x193c <__vector_16+0x3a>
    1934:	01 96       	adiw	r24, 0x01	; 1
    1936:	a1 1d       	adc	r26, r1
    1938:	b1 1d       	adc	r27, r1
    193a:	05 c0       	rjmp	.+10     	; 0x1946 <__vector_16+0x44>
    193c:	26 e8       	ldi	r18, 0x86	; 134
    193e:	23 0f       	add	r18, r19
    1940:	02 96       	adiw	r24, 0x02	; 2
    1942:	a1 1d       	adc	r26, r1
    1944:	b1 1d       	adc	r27, r1
    1946:	20 93 4e 05 	sts	0x054E, r18	; 0x80054e <timer0_fract>
    194a:	80 93 4f 05 	sts	0x054F, r24	; 0x80054f <timer0_millis>
    194e:	90 93 50 05 	sts	0x0550, r25	; 0x800550 <timer0_millis+0x1>
    1952:	a0 93 51 05 	sts	0x0551, r26	; 0x800551 <timer0_millis+0x2>
    1956:	b0 93 52 05 	sts	0x0552, r27	; 0x800552 <timer0_millis+0x3>
    195a:	80 91 53 05 	lds	r24, 0x0553	; 0x800553 <timer0_overflow_count>
    195e:	90 91 54 05 	lds	r25, 0x0554	; 0x800554 <timer0_overflow_count+0x1>
    1962:	a0 91 55 05 	lds	r26, 0x0555	; 0x800555 <timer0_overflow_count+0x2>
    1966:	b0 91 56 05 	lds	r27, 0x0556	; 0x800556 <timer0_overflow_count+0x3>
    196a:	01 96       	adiw	r24, 0x01	; 1
    196c:	a1 1d       	adc	r26, r1
    196e:	b1 1d       	adc	r27, r1
    1970:	80 93 53 05 	sts	0x0553, r24	; 0x800553 <timer0_overflow_count>
    1974:	90 93 54 05 	sts	0x0554, r25	; 0x800554 <timer0_overflow_count+0x1>
    1978:	a0 93 55 05 	sts	0x0555, r26	; 0x800555 <timer0_overflow_count+0x2>
    197c:	b0 93 56 05 	sts	0x0556, r27	; 0x800556 <timer0_overflow_count+0x3>
    1980:	bf 91       	pop	r27
    1982:	af 91       	pop	r26
    1984:	9f 91       	pop	r25
    1986:	8f 91       	pop	r24
    1988:	3f 91       	pop	r19
    198a:	2f 91       	pop	r18
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	0f 90       	pop	r0
    1992:	1f 90       	pop	r1
    1994:	18 95       	reti

00001996 <millis>:
    1996:	2f b7       	in	r18, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	60 91 4f 05 	lds	r22, 0x054F	; 0x80054f <timer0_millis>
    199e:	70 91 50 05 	lds	r23, 0x0550	; 0x800550 <timer0_millis+0x1>
    19a2:	80 91 51 05 	lds	r24, 0x0551	; 0x800551 <timer0_millis+0x2>
    19a6:	90 91 52 05 	lds	r25, 0x0552	; 0x800552 <timer0_millis+0x3>
    19aa:	2f bf       	out	0x3f, r18	; 63
    19ac:	08 95       	ret

000019ae <micros>:
    19ae:	3f b7       	in	r19, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	80 91 53 05 	lds	r24, 0x0553	; 0x800553 <timer0_overflow_count>
    19b6:	90 91 54 05 	lds	r25, 0x0554	; 0x800554 <timer0_overflow_count+0x1>
    19ba:	a0 91 55 05 	lds	r26, 0x0555	; 0x800555 <timer0_overflow_count+0x2>
    19be:	b0 91 56 05 	lds	r27, 0x0556	; 0x800556 <timer0_overflow_count+0x3>
    19c2:	26 b5       	in	r18, 0x26	; 38
    19c4:	a8 9b       	sbis	0x15, 0	; 21
    19c6:	05 c0       	rjmp	.+10     	; 0x19d2 <micros+0x24>
    19c8:	2f 3f       	cpi	r18, 0xFF	; 255
    19ca:	19 f0       	breq	.+6      	; 0x19d2 <micros+0x24>
    19cc:	01 96       	adiw	r24, 0x01	; 1
    19ce:	a1 1d       	adc	r26, r1
    19d0:	b1 1d       	adc	r27, r1
    19d2:	3f bf       	out	0x3f, r19	; 63
    19d4:	ba 2f       	mov	r27, r26
    19d6:	a9 2f       	mov	r26, r25
    19d8:	98 2f       	mov	r25, r24
    19da:	88 27       	eor	r24, r24
    19dc:	82 0f       	add	r24, r18
    19de:	91 1d       	adc	r25, r1
    19e0:	a1 1d       	adc	r26, r1
    19e2:	b1 1d       	adc	r27, r1
    19e4:	bc 01       	movw	r22, r24
    19e6:	cd 01       	movw	r24, r26
    19e8:	42 e0       	ldi	r20, 0x02	; 2
    19ea:	66 0f       	add	r22, r22
    19ec:	77 1f       	adc	r23, r23
    19ee:	88 1f       	adc	r24, r24
    19f0:	99 1f       	adc	r25, r25
    19f2:	4a 95       	dec	r20
    19f4:	d1 f7       	brne	.-12     	; 0x19ea <micros+0x3c>
    19f6:	08 95       	ret

000019f8 <delay>:
    19f8:	8f 92       	push	r8
    19fa:	9f 92       	push	r9
    19fc:	af 92       	push	r10
    19fe:	bf 92       	push	r11
    1a00:	cf 92       	push	r12
    1a02:	df 92       	push	r13
    1a04:	ef 92       	push	r14
    1a06:	ff 92       	push	r15
    1a08:	6b 01       	movw	r12, r22
    1a0a:	7c 01       	movw	r14, r24
    1a0c:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
    1a10:	4b 01       	movw	r8, r22
    1a12:	5c 01       	movw	r10, r24
    1a14:	c1 14       	cp	r12, r1
    1a16:	d1 04       	cpc	r13, r1
    1a18:	e1 04       	cpc	r14, r1
    1a1a:	f1 04       	cpc	r15, r1
    1a1c:	01 f1       	breq	.+64     	; 0x1a5e <delay+0x66>
    1a1e:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <yield>
    1a22:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <micros>
    1a26:	dc 01       	movw	r26, r24
    1a28:	cb 01       	movw	r24, r22
    1a2a:	88 19       	sub	r24, r8
    1a2c:	99 09       	sbc	r25, r9
    1a2e:	aa 09       	sbc	r26, r10
    1a30:	bb 09       	sbc	r27, r11
    1a32:	88 3e       	cpi	r24, 0xE8	; 232
    1a34:	93 40       	sbci	r25, 0x03	; 3
    1a36:	a1 05       	cpc	r26, r1
    1a38:	b1 05       	cpc	r27, r1
    1a3a:	60 f3       	brcs	.-40     	; 0x1a14 <delay+0x1c>
    1a3c:	21 e0       	ldi	r18, 0x01	; 1
    1a3e:	c2 1a       	sub	r12, r18
    1a40:	d1 08       	sbc	r13, r1
    1a42:	e1 08       	sbc	r14, r1
    1a44:	f1 08       	sbc	r15, r1
    1a46:	88 ee       	ldi	r24, 0xE8	; 232
    1a48:	88 0e       	add	r8, r24
    1a4a:	83 e0       	ldi	r24, 0x03	; 3
    1a4c:	98 1e       	adc	r9, r24
    1a4e:	a1 1c       	adc	r10, r1
    1a50:	b1 1c       	adc	r11, r1
    1a52:	c1 14       	cp	r12, r1
    1a54:	d1 04       	cpc	r13, r1
    1a56:	e1 04       	cpc	r14, r1
    1a58:	f1 04       	cpc	r15, r1
    1a5a:	19 f7       	brne	.-58     	; 0x1a22 <delay+0x2a>
    1a5c:	db cf       	rjmp	.-74     	; 0x1a14 <delay+0x1c>
    1a5e:	ff 90       	pop	r15
    1a60:	ef 90       	pop	r14
    1a62:	df 90       	pop	r13
    1a64:	cf 90       	pop	r12
    1a66:	bf 90       	pop	r11
    1a68:	af 90       	pop	r10
    1a6a:	9f 90       	pop	r9
    1a6c:	8f 90       	pop	r8
    1a6e:	08 95       	ret

00001a70 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    1a70:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    1a72:	84 b5       	in	r24, 0x24	; 36
    1a74:	82 60       	ori	r24, 0x02	; 2
    1a76:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    1a78:	84 b5       	in	r24, 0x24	; 36
    1a7a:	81 60       	ori	r24, 0x01	; 1
    1a7c:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    1a7e:	85 b5       	in	r24, 0x25	; 37
    1a80:	82 60       	ori	r24, 0x02	; 2
    1a82:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    1a84:	85 b5       	in	r24, 0x25	; 37
    1a86:	81 60       	ori	r24, 0x01	; 1
    1a88:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    1a8a:	ee e6       	ldi	r30, 0x6E	; 110
    1a8c:	f0 e0       	ldi	r31, 0x00	; 0
    1a8e:	80 81       	ld	r24, Z
    1a90:	81 60       	ori	r24, 0x01	; 1
    1a92:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    1a94:	e1 e8       	ldi	r30, 0x81	; 129
    1a96:	f0 e0       	ldi	r31, 0x00	; 0
    1a98:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    1a9a:	80 81       	ld	r24, Z
    1a9c:	82 60       	ori	r24, 0x02	; 2
    1a9e:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    1aa0:	80 81       	ld	r24, Z
    1aa2:	81 60       	ori	r24, 0x01	; 1
    1aa4:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    1aa6:	e0 e8       	ldi	r30, 0x80	; 128
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	80 81       	ld	r24, Z
    1aac:	81 60       	ori	r24, 0x01	; 1
    1aae:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    1ab0:	e1 eb       	ldi	r30, 0xB1	; 177
    1ab2:	f0 e0       	ldi	r31, 0x00	; 0
    1ab4:	80 81       	ld	r24, Z
    1ab6:	84 60       	ori	r24, 0x04	; 4
    1ab8:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    1aba:	e0 eb       	ldi	r30, 0xB0	; 176
    1abc:	f0 e0       	ldi	r31, 0x00	; 0
    1abe:	80 81       	ld	r24, Z
    1ac0:	81 60       	ori	r24, 0x01	; 1
    1ac2:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    1ac4:	ea e7       	ldi	r30, 0x7A	; 122
    1ac6:	f0 e0       	ldi	r31, 0x00	; 0
    1ac8:	80 81       	ld	r24, Z
    1aca:	84 60       	ori	r24, 0x04	; 4
    1acc:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    1ace:	80 81       	ld	r24, Z
    1ad0:	82 60       	ori	r24, 0x02	; 2
    1ad2:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    1ad4:	80 81       	ld	r24, Z
    1ad6:	81 60       	ori	r24, 0x01	; 1
    1ad8:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    1ada:	80 81       	ld	r24, Z
    1adc:	80 68       	ori	r24, 0x80	; 128
    1ade:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    1ae0:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1ae4:	08 95       	ret

00001ae6 <__mulsi3>:
    1ae6:	db 01       	movw	r26, r22
    1ae8:	8f 93       	push	r24
    1aea:	9f 93       	push	r25
    1aec:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <__muluhisi3>
    1af0:	bf 91       	pop	r27
    1af2:	af 91       	pop	r26
    1af4:	a2 9f       	mul	r26, r18
    1af6:	80 0d       	add	r24, r0
    1af8:	91 1d       	adc	r25, r1
    1afa:	a3 9f       	mul	r26, r19
    1afc:	90 0d       	add	r25, r0
    1afe:	b2 9f       	mul	r27, r18
    1b00:	90 0d       	add	r25, r0
    1b02:	11 24       	eor	r1, r1
    1b04:	08 95       	ret

00001b06 <__udivmodhi4>:
    1b06:	aa 1b       	sub	r26, r26
    1b08:	bb 1b       	sub	r27, r27
    1b0a:	51 e1       	ldi	r21, 0x11	; 17
    1b0c:	07 c0       	rjmp	.+14     	; 0x1b1c <__udivmodhi4_ep>

00001b0e <__udivmodhi4_loop>:
    1b0e:	aa 1f       	adc	r26, r26
    1b10:	bb 1f       	adc	r27, r27
    1b12:	a6 17       	cp	r26, r22
    1b14:	b7 07       	cpc	r27, r23
    1b16:	10 f0       	brcs	.+4      	; 0x1b1c <__udivmodhi4_ep>
    1b18:	a6 1b       	sub	r26, r22
    1b1a:	b7 0b       	sbc	r27, r23

00001b1c <__udivmodhi4_ep>:
    1b1c:	88 1f       	adc	r24, r24
    1b1e:	99 1f       	adc	r25, r25
    1b20:	5a 95       	dec	r21
    1b22:	a9 f7       	brne	.-22     	; 0x1b0e <__udivmodhi4_loop>
    1b24:	80 95       	com	r24
    1b26:	90 95       	com	r25
    1b28:	bc 01       	movw	r22, r24
    1b2a:	cd 01       	movw	r24, r26
    1b2c:	08 95       	ret

00001b2e <__divmodhi4>:
    1b2e:	97 fb       	bst	r25, 7
    1b30:	07 2e       	mov	r0, r23
    1b32:	16 f4       	brtc	.+4      	; 0x1b38 <__divmodhi4+0xa>
    1b34:	00 94       	com	r0
    1b36:	07 d0       	rcall	.+14     	; 0x1b46 <__divmodhi4_neg1>
    1b38:	77 fd       	sbrc	r23, 7
    1b3a:	09 d0       	rcall	.+18     	; 0x1b4e <__divmodhi4_neg2>
    1b3c:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <__udivmodhi4>
    1b40:	07 fc       	sbrc	r0, 7
    1b42:	05 d0       	rcall	.+10     	; 0x1b4e <__divmodhi4_neg2>
    1b44:	3e f4       	brtc	.+14     	; 0x1b54 <__divmodhi4_exit>

00001b46 <__divmodhi4_neg1>:
    1b46:	90 95       	com	r25
    1b48:	81 95       	neg	r24
    1b4a:	9f 4f       	sbci	r25, 0xFF	; 255
    1b4c:	08 95       	ret

00001b4e <__divmodhi4_neg2>:
    1b4e:	70 95       	com	r23
    1b50:	61 95       	neg	r22
    1b52:	7f 4f       	sbci	r23, 0xFF	; 255

00001b54 <__divmodhi4_exit>:
    1b54:	08 95       	ret

00001b56 <__udivmodsi4>:
    1b56:	a1 e2       	ldi	r26, 0x21	; 33
    1b58:	1a 2e       	mov	r1, r26
    1b5a:	aa 1b       	sub	r26, r26
    1b5c:	bb 1b       	sub	r27, r27
    1b5e:	fd 01       	movw	r30, r26
    1b60:	0d c0       	rjmp	.+26     	; 0x1b7c <__udivmodsi4_ep>

00001b62 <__udivmodsi4_loop>:
    1b62:	aa 1f       	adc	r26, r26
    1b64:	bb 1f       	adc	r27, r27
    1b66:	ee 1f       	adc	r30, r30
    1b68:	ff 1f       	adc	r31, r31
    1b6a:	a2 17       	cp	r26, r18
    1b6c:	b3 07       	cpc	r27, r19
    1b6e:	e4 07       	cpc	r30, r20
    1b70:	f5 07       	cpc	r31, r21
    1b72:	20 f0       	brcs	.+8      	; 0x1b7c <__udivmodsi4_ep>
    1b74:	a2 1b       	sub	r26, r18
    1b76:	b3 0b       	sbc	r27, r19
    1b78:	e4 0b       	sbc	r30, r20
    1b7a:	f5 0b       	sbc	r31, r21

00001b7c <__udivmodsi4_ep>:
    1b7c:	66 1f       	adc	r22, r22
    1b7e:	77 1f       	adc	r23, r23
    1b80:	88 1f       	adc	r24, r24
    1b82:	99 1f       	adc	r25, r25
    1b84:	1a 94       	dec	r1
    1b86:	69 f7       	brne	.-38     	; 0x1b62 <__udivmodsi4_loop>
    1b88:	60 95       	com	r22
    1b8a:	70 95       	com	r23
    1b8c:	80 95       	com	r24
    1b8e:	90 95       	com	r25
    1b90:	9b 01       	movw	r18, r22
    1b92:	ac 01       	movw	r20, r24
    1b94:	bd 01       	movw	r22, r26
    1b96:	cf 01       	movw	r24, r30
    1b98:	08 95       	ret

00001b9a <__divmodsi4>:
    1b9a:	05 2e       	mov	r0, r21
    1b9c:	97 fb       	bst	r25, 7
    1b9e:	1e f4       	brtc	.+6      	; 0x1ba6 <__divmodsi4+0xc>
    1ba0:	00 94       	com	r0
    1ba2:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__negsi2>
    1ba6:	57 fd       	sbrc	r21, 7
    1ba8:	07 d0       	rcall	.+14     	; 0x1bb8 <__divmodsi4_neg2>
    1baa:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <__udivmodsi4>
    1bae:	07 fc       	sbrc	r0, 7
    1bb0:	03 d0       	rcall	.+6      	; 0x1bb8 <__divmodsi4_neg2>
    1bb2:	4e f4       	brtc	.+18     	; 0x1bc6 <__divmodsi4_exit>
    1bb4:	0c 94 e4 0d 	jmp	0x1bc8	; 0x1bc8 <__negsi2>

00001bb8 <__divmodsi4_neg2>:
    1bb8:	50 95       	com	r21
    1bba:	40 95       	com	r20
    1bbc:	30 95       	com	r19
    1bbe:	21 95       	neg	r18
    1bc0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc2:	4f 4f       	sbci	r20, 0xFF	; 255
    1bc4:	5f 4f       	sbci	r21, 0xFF	; 255

00001bc6 <__divmodsi4_exit>:
    1bc6:	08 95       	ret

00001bc8 <__negsi2>:
    1bc8:	90 95       	com	r25
    1bca:	80 95       	com	r24
    1bcc:	70 95       	com	r23
    1bce:	61 95       	neg	r22
    1bd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd2:	8f 4f       	sbci	r24, 0xFF	; 255
    1bd4:	9f 4f       	sbci	r25, 0xFF	; 255
    1bd6:	08 95       	ret

00001bd8 <__usmulhisi3>:
    1bd8:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <__umulhisi3>

00001bdc <__usmulhisi3_tail>:
    1bdc:	b7 ff       	sbrs	r27, 7
    1bde:	08 95       	ret
    1be0:	82 1b       	sub	r24, r18
    1be2:	93 0b       	sbc	r25, r19
    1be4:	08 95       	ret

00001be6 <__muluhisi3>:
    1be6:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <__umulhisi3>
    1bea:	a5 9f       	mul	r26, r21
    1bec:	90 0d       	add	r25, r0
    1bee:	b4 9f       	mul	r27, r20
    1bf0:	90 0d       	add	r25, r0
    1bf2:	a4 9f       	mul	r26, r20
    1bf4:	80 0d       	add	r24, r0
    1bf6:	91 1d       	adc	r25, r1
    1bf8:	11 24       	eor	r1, r1
    1bfa:	08 95       	ret

00001bfc <__tablejump2__>:
    1bfc:	ee 0f       	add	r30, r30
    1bfe:	ff 1f       	adc	r31, r31
    1c00:	05 90       	lpm	r0, Z+
    1c02:	f4 91       	lpm	r31, Z
    1c04:	e0 2d       	mov	r30, r0
    1c06:	09 94       	ijmp

00001c08 <__umulhisi3>:
    1c08:	a2 9f       	mul	r26, r18
    1c0a:	b0 01       	movw	r22, r0
    1c0c:	b3 9f       	mul	r27, r19
    1c0e:	c0 01       	movw	r24, r0
    1c10:	a3 9f       	mul	r26, r19
    1c12:	70 0d       	add	r23, r0
    1c14:	81 1d       	adc	r24, r1
    1c16:	11 24       	eor	r1, r1
    1c18:	91 1d       	adc	r25, r1
    1c1a:	b2 9f       	mul	r27, r18
    1c1c:	70 0d       	add	r23, r0
    1c1e:	81 1d       	adc	r24, r1
    1c20:	11 24       	eor	r1, r1
    1c22:	91 1d       	adc	r25, r1
    1c24:	08 95       	ret

00001c26 <_exit>:
    1c26:	f8 94       	cli

00001c28 <__stop_program>:
    1c28:	ff cf       	rjmp	.-2      	; 0x1c28 <__stop_program>
